# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `flay` gem.
# Please instead update this file by running `bin/tapioca gem flay`.

class Array
  include ::Enumerable

  # Delete anything in +self+ if they are identical to anything in +other+.
  #
  # source://flay//lib/flay.rb#662
  def delete_eql(other); end
end

class Flay
  # Create a new instance of Flay with +option+s.
  #
  # @return [Flay] a new instance of Flay
  #
  # source://flay//lib/flay.rb#165
  def initialize(option = T.unsafe(nil)); end

  # Prune, find identical nodes, and update masses.
  #
  # source://flay//lib/flay.rb#212
  def analyze(filter = T.unsafe(nil)); end

  # source://flay//lib/flay.rb#447
  def collapse_and_label(ary); end

  # Before processing, filter any sexp's that match against filters
  # specified in +option[:filters]+. This changes the sexp itself.
  #
  # source://flay//lib/flay.rb#279
  def filter_sexp(exp); end

  # Returns the value of attribute hashes.
  #
  # source://flay//lib/flay.rb#159
  def hashes; end

  # :stopdoc:
  #
  # source://flay//lib/flay.rb#158
  def identical; end

  # :stopdoc:
  #
  # source://flay//lib/flay.rb#158
  def identical=(_arg0); end

  # :stopdoc:
  #
  # source://flay//lib/flay.rb#158
  def mass_threshold; end

  # :stopdoc:
  #
  # source://flay//lib/flay.rb#158
  def mass_threshold=(_arg0); end

  # :stopdoc:
  #
  # source://flay//lib/flay.rb#158
  def masses; end

  # :stopdoc:
  #
  # source://flay//lib/flay.rb#158
  def masses=(_arg0); end

  # Output an n-way diff from +data+. This is only used if --diff is
  # given.
  #
  # source://flay//lib/flay.rb#411
  def n_way_diff(*data); end

  # Returns the value of attribute option.
  #
  # source://flay//lib/flay.rb#159
  def option; end

  # source://flay//lib/flay.rb#441
  def pad_with_empty_strings(ary); end

  # Process any number of files.
  #
  # source://flay//lib/flay.rb#178
  def process(*files); end

  # Process "fuzzy" matches for +node+. A fuzzy match is a subset of
  # +node+ up to +difference+ elements less than the original.
  #
  # source://flay//lib/flay.rb#311
  def process_fuzzy(node, difference); end

  # Parse a ruby +file+ and return the sexp.
  #
  # --
  # TODO: change the system and rename this to parse_rb.
  #
  # source://flay//lib/flay.rb#267
  def process_rb(file); end

  # Process a sexp +pt+.
  #
  # source://flay//lib/flay.rb#291
  def process_sexp(pt); end

  # Prunes nodes that aren't relevant to analysis or are already
  # covered by another node. Also deletes nodes based on the
  # +:filters+ option.
  #
  # source://flay//lib/flay.rb#342
  def prune; end

  # Conservative prune. Remove any bucket that is known to contain a
  # subnode element of a node in another bucket.
  #
  # source://flay//lib/flay.rb#358
  def prune_conservatively; end

  # Liberal prune. Remove any _element_ from a bucket that is known to
  # be a subnode of another node. Removed by identity.
  #
  # source://flay//lib/flay.rb#376
  def prune_liberally; end

  # Output the report. Duh.
  #
  # source://flay//lib/flay.rb#477
  def report(io = T.unsafe(nil)); end

  # source://flay//lib/flay.rb#524
  def sexp_to_rb(sexp); end

  # source://flay//lib/flay.rb#431
  def split_and_group(ary); end

  # Calculate summary scores on a per-file basis. For --summary.
  #
  # source://flay//lib/flay.rb#460
  def summary; end

  # :stopdoc:
  #
  # source://flay//lib/flay.rb#158
  def total; end

  # :stopdoc:
  #
  # source://flay//lib/flay.rb#158
  def total=(_arg0); end

  # Reset total and recalculate the masses for all nodes in +hashes+.
  #
  # source://flay//lib/flay.rb#251
  def update_masses; end

  class << self
    # Returns the default options.
    #
    # source://flay//lib/flay.rb#36
    def default_options; end

    # Loads all flay plugins. Files must be named "flay_*.rb".
    #
    # source://flay//lib/flay.rb#135
    def load_plugins; end

    # Process options in +args+, defaulting to +ARGV+.
    #
    # source://flay//lib/flay.rb#54
    def parse_options(args = T.unsafe(nil)); end

    # source://flay//lib/flay.rb#21
    def run(args = T.unsafe(nil)); end
  end
end

# so I can move this to flog wholesale
#
# source://flay//lib/flay.rb#130
Flay::DEFAULT_IGNORE = T.let(T.unsafe(nil), String)

class Flay::Item < ::Struct
  # Returns the value of attribute bonus
  #
  # @return [Object] the current value of bonus
  def identical?; end
end

class Flay::Location < ::Struct
  # Returns the value of attribute fuzzy
  #
  # @return [Object] the current value of fuzzy
  def fuzzy?; end
end

# prevents exponential blowout
#
# source://flay//lib/flay.rb#304
Flay::MAX_AVG_MASS = T.let(T.unsafe(nil), Integer)

# :stopdoc:
#
# source://flay//lib/flay.rb#303
Flay::MAX_NODE_SIZE = T.let(T.unsafe(nil), Integer)

# source://flay//lib/flay.rb#11
Flay::VERSION = T.let(T.unsafe(nil), String)

module Kwalify::Scalar; end

module Kwalify::Text
  include ::Kwalify::Scalar
end

# straight from flay-persistent
class Sexp < ::Array
  # source://sexp_processor/4.16.1/lib/sexp.rb#30
  def initialize(*args); end

  # source://flay//lib/flay.rb#587
  def +(o); end

  # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#30
  def /(pattern); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#70
  def ==(obj); end

  # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#8
  def =~(pattern); end

  # source://flay//lib/flay.rb#576
  def [](a); end

  def _concat(*_arg0); end

  # Returns a list of structural hashes for all nodes (and sub-nodes)
  # of this sexp.
  #
  # source://flay//lib/flay.rb#558
  def all_structural_subhashes; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#87
  def array_type?; end

  # source://ruby_parser/3.19.1/lib/rp_extensions.rb#47
  def block_pass?; end

  # source://ruby_parser/3.19.1/lib/ruby_parser_extras.rb#12
  def check_line_numbers; end

  # Return the index of the last non-code element, or nil if this sexp
  # is not a code-bearing node.
  #
  # source://flay//lib/flay.rb#603
  def code_index; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#23
  def comments; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#23
  def comments=(_arg0); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#93
  def compact; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#107
  def deep_each(&block); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#119
  def depth; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#126
  def each_of_type(t, &b); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#138
  def each_sexp; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#74
  def eql?(o); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#18
  def file; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#18
  def file=(_arg0); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#152
  def find_and_replace_all(from, to); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#193
  def find_node(name, delete = T.unsafe(nil)); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#211
  def find_nodes(name); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#165
  def gsub(pattern, repl); end

  # Return the index of the last non-code element, or nil if this sexp
  # is not a code-bearing node.
  # Does this sexp have a +*code+ section?
  #
  # source://flay//lib/flay.rb#603
  def has_code?; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#78
  def hash; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#278
  def head; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#184
  def inspect; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#222
  def line(n = T.unsafe(nil)); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#13
  def line=(_arg0); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#235
  def line_max; end

  # source://ruby_parser/3.19.1/lib/ruby_parser_extras.rb#23
  def line_min; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#66
  def map(&blk); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#242
  def mass; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#249
  def method_missing(meth, delete = T.unsafe(nil)); end

  # Whether or not this sexp is a mutated/modified sexp.
  #
  # source://flay//lib/flay.rb#543
  def modified; end

  # Whether or not this sexp is a mutated/modified sexp.
  #
  # source://flay//lib/flay.rb#543
  def modified=(_arg0); end

  # Whether or not this sexp is a mutated/modified sexp.
  # Is this sexp modified?
  #
  # source://flay//lib/flay.rb#543
  def modified?; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#58
  def new(*body); end

  # source://ruby_parser/3.19.1/lib/ruby_parser_extras.rb#27
  def nil_line?; end

  # source://ruby_parser/3.19.1/lib/rp_extensions.rb#43
  def paren; end

  # source://ruby_parser/3.19.1/lib/rp_extensions.rb#41
  def paren=(_arg0); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#266
  def pretty_print(q); end

  # source://flay//lib/flay.rb#631
  def pure_ruby_hash; end

  # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#57
  def replace_sexp(pattern, &block); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#261
  def respond_to?(msg, private = T.unsafe(nil)); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#293
  def rest(from = T.unsafe(nil)); end

  # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#19
  def satisfy?(pattern); end

  # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#38
  def search_each(pattern, &block); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#293
  def sexp_body(from = T.unsafe(nil)); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#300
  def sexp_body=(v); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#278
  def sexp_type; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#285
  def sexp_type=(v); end

  # Useful general array method that splits the array from 0..+n+ and
  # the rest. Returns both sections.
  #
  # source://flay//lib/flay.rb#595
  def split_at(n); end

  # Split the sexp into front-matter and code-matter, returning both.
  # See #code_index.
  #
  # source://flay//lib/flay.rb#620
  def split_code; end

  # Calculate the structural hash for this sexp. Cached, so don't
  # modify the sexp afterwards and expect it to be correct.
  #
  # source://flay//lib/flay.rb#550
  def structural_hash; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#320
  def structure; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#332
  def sub(pattern, repl); end

  # source://sexp_processor/4.16.1/lib/sexp.rb#362
  def to_a; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#184
  def to_s; end

  # source://sexp_processor/4.16.1/lib/sexp.rb#371
  def value; end

  private

  # source://flay//lib/flay.rb#566
  def initialize_copy(o); end

  class << self
    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#155
    def -(arg); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#93
    def _; end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#104
    def ___; end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#144
    def all(*args); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#133
    def any(*args); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#122
    def atom; end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#170
    def child(child); end

    # source://sexp_processor/4.16.1/lib/sexp.rb#39
    def from_array(a); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#113
    def include(child); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#208
    def k(klass); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#190
    def m(*values); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#155
    def not?(arg); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#78
    def q(*args); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#82
    def s(*args); end

    # source://sexp_processor/4.16.1/lib/sexp_matcher.rb#180
    def t(name); end
  end
end

# source://flay//lib/flay.rb#629
Sexp::MAX_INT32 = T.let(T.unsafe(nil), Integer)

# source://flay//lib/flay.rb#627
Sexp::NODE_NAMES = T.let(T.unsafe(nil), Hash)

# source://sexp_processor/4.16.1/lib/sexp.rb#215
Sexp::UNASSIGNED = T.let(T.unsafe(nil), Object)

class String
  include ::Comparable
  include ::Kwalify::Text
  include ::Kwalify::Scalar

  # source://flay//lib/flay.rb#536
  def group; end

  # source://flay//lib/flay.rb#536
  def group=(_arg0); end
end
