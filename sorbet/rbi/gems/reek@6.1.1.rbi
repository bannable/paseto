# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `reek` gem.
# Please instead update this file by running `bin/tapioca gem reek`.

module Reek; end

# Represents functionality related to an Abstract Syntax Tree.
module Reek::AST; end

# Maps AST node types to sublasses of ASTNode extended with the relevant
# utility modules.
class Reek::AST::ASTNodeClassMap
  # @return [ASTNodeClassMap] a new instance of ASTNodeClassMap
  #
  # source://reek//lib/reek/ast/ast_node_class_map.rb#12
  def initialize; end

  # source://reek//lib/reek/ast/ast_node_class_map.rb#24
  def extension_map; end

  # source://reek//lib/reek/ast/ast_node_class_map.rb#16
  def klass_for(type); end

  private

  # Returns the value of attribute klass_map.
  #
  # source://reek//lib/reek/ast/ast_node_class_map.rb#39
  def klass_map; end
end

# An AST Builder for ruby parser.
class Reek::AST::Builder < ::Parser::Builders::Default
  # This is a work around for parsing ruby code that has a string with invalid sequence as UTF-8.
  # See. https://github.com/whitequark/parser/issues/283
  #
  # source://reek//lib/reek/ast/builder.rb#11
  def string_value(token); end
end

# Base class for AST nodes extended with utility methods. Contains some
# methods to ease the transition from Sexp to AST::Node.
class Reek::AST::Node < ::Parser::AST::Node
  # @return [Node] a new instance of Node
  #
  # source://reek//lib/reek/ast/node.rb#12
  def initialize(type, children = T.unsafe(nil), options = T.unsafe(nil)); end

  # Method will be overridden by the code in the IfNode, CaseNode, and LogicOperatorBase sexp extensions.
  #
  # source://reek//lib/reek/ast/node.rb#106
  def condition; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/node.rb#68
  def contains_nested_node?(target_type); end

  # Carries out a depth-first traversal of this syntax tree, yielding every
  # Sexp of the searched for type or types. The traversal stops at any node
  # whose type is listed in `ignoring`.
  #
  # If a type is searched for *and* listed in ignoring, it will be yielded
  # but traversal will not continue to its children.
  #
  # If the root's type is ignored, traversal does not stop, unless the root
  # is of a target type.
  #
  # Takes a block as well.
  #
  # Returns an array with all matching nodes.
  #
  # @example
  #   node.each_node(:send, [:mlhs]) do |call_node| .... end
  #   node.each_node(:lvar).any? { |it| it.var_name == 'something' }
  #   node.each_node([:block]).flat_map do |elem| ... end
  # @param target_types [Symbol, Array<Symbol>] the type or types to look
  #   for
  # @param ignoring [Array<Symbol>] types to ignore
  # @param blk block to execute for every hit. Gets passed in the
  #   matching element itself.
  #
  # source://reek//lib/reek/ast/node.rb#62
  def each_node(target_types, ignoring = T.unsafe(nil), &blk); end

  # source://reek//lib/reek/ast/node.rb#74
  def format_to_ruby; end

  # source://reek//lib/reek/ast/node.rb#17
  def full_comment; end

  # source://reek//lib/reek/ast/node.rb#21
  def leading_comment; end

  # Provide length for statement counting. A sexp counts as one statement.
  #
  # source://reek//lib/reek/ast/node.rb#88
  def length; end

  # source://reek//lib/reek/ast/node.rb#29
  def line; end

  # source://reek//lib/reek/ast/node.rb#33
  def name; end

  # source://reek//lib/reek/ast/node.rb#101
  def source; end

  # Most nodes represent only one statement (although they can have nested
  # statements). The special type :begin exists primarily to contain more
  # statements.
  #
  # @return Array of unique outer-level statements contained in this node
  #
  # source://reek//lib/reek/ast/node.rb#97
  def statements; end

  protected

  # See ".each_node" for documentation.
  #
  # source://reek//lib/reek/ast/node.rb#111
  def look_for(target_types, ignoring, &blk); end

  # See ".each_node" for documentation.
  #
  # @yield [_self]
  # @yieldparam _self [Reek::AST::Node] the object that the method was called on
  #
  # source://reek//lib/reek/ast/node.rb#122
  def look_for_recurse(target_types, ignoring, &blk); end

  private

  # Returns the value of attribute comments.
  #
  # source://reek//lib/reek/ast/node.rb#133
  def comments; end

  # source://reek//lib/reek/ast/node.rb#135
  def each_sexp; end
end

# ObjectRefs is used in CodeContexts.
# It manages and counts the references out of a method to other objects and to `self`.
#
# E.g. this code:
#   def foo(thing)
#     bar.call_me
#     bar.maybe(thing.wat)
#   end
#
# would make "@refs" below look like this after the TreeWalker has done his job:
#   {
#     :self=>[2, 3], # `bar.call_me` and `bar.maybe` count as refs to `self` in line 2 and 3
#     :thing=>[3]    # `thing.wat` in `bar.maybe()` counts as one reference to `thing`
#   }
class Reek::AST::ObjectRefs
  # @return [ObjectRefs] a new instance of ObjectRefs
  #
  # source://reek//lib/reek/ast/object_refs.rb#23
  def initialize; end

  # E.g. for
  #   { foo: [2], self: [2,3], bar: [3,4] }
  # this would return
  #   { self: [2,3], bar: [3,4] }
  #
  # @return [Hash] The most popular references.
  #
  # source://reek//lib/reek/ast/object_refs.rb#43
  def most_popular; end

  # Records the references a given method in a CodeContext has including
  # `self` (see the example at the beginning of this file).
  #
  # @param name [Symbol] The name of the object that the method references or `self`.
  # @param line [Int] The line number where this reference occurs.
  # @return [Int|nil] The line number that was added (which might be nil).
  #
  # source://reek//lib/reek/ast/object_refs.rb#34
  def record_reference(name:, line: T.unsafe(nil)); end

  # source://reek//lib/reek/ast/object_refs.rb#48
  def references_to(name); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/object_refs.rb#52
  def self_is_max?; end

  private

  # Returns the value of attribute refs.
  #
  # source://reek//lib/reek/ast/object_refs.rb#58
  def refs; end
end

# Locates references to the current object within a portion
# of an abstract syntax tree.
class Reek::AST::ReferenceCollector
  # @return [ReferenceCollector] a new instance of ReferenceCollector
  #
  # source://reek//lib/reek/ast/reference_collector.rb#10
  def initialize(ast); end

  # source://reek//lib/reek/ast/reference_collector.rb#14
  def num_refs_to_self; end

  private

  # Returns the value of attribute ast.
  #
  # source://reek//lib/reek/ast/reference_collector.rb#20
  def ast; end

  # source://reek//lib/reek/ast/reference_collector.rb#22
  def explicit_self_calls; end

  # source://reek//lib/reek/ast/reference_collector.rb#26
  def implicit_self_calls; end
end

module Reek::AST::SexpExtensions; end

# Utility methods for :and nodes.
module Reek::AST::SexpExtensions::AndNode
  include ::Reek::AST::SexpExtensions::LogicOperatorBase
end

# Utility methods for :arg nodes.
module Reek::AST::SexpExtensions::ArgNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase
end

# Base module for utility methods for argument nodes.
module Reek::AST::SexpExtensions::ArgNodeBase
  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#28
  def anonymous_splat?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#20
  def block?; end

  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#32
  def components; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#12
  def marked_unused?; end

  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#8
  def name; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#24
  def optional_argument?; end

  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#16
  def plain_name; end
end

# Utility methods for :args nodes.
module Reek::AST::SexpExtensions::ArgsNode
  include ::Reek::AST::SexpExtensions::NestedAssignables
end

# Utility methods for :begin nodes.
module Reek::AST::SexpExtensions::BeginNode
  # The special type :begin exists primarily to contain more statements.
  # Therefore, this method overrides the default implementation to return
  # this node's children.
  #
  # source://reek//lib/reek/ast/sexp_extensions/begin.rb#11
  def statements; end
end

# Utility methods for :block nodes.
module Reek::AST::SexpExtensions::BlockNode
  # source://reek//lib/reek/ast/sexp_extensions/block.rb#12
  def args; end

  # source://reek//lib/reek/ast/sexp_extensions/block.rb#16
  def block; end

  # source://reek//lib/reek/ast/sexp_extensions/block.rb#8
  def call; end

  # source://reek//lib/reek/ast/sexp_extensions/block.rb#24
  def parameter_names; end

  # source://reek//lib/reek/ast/sexp_extensions/block.rb#20
  def parameters; end

  # source://reek//lib/reek/ast/sexp_extensions/block.rb#28
  def simple_name; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/block.rb#32
  def without_block_arguments?; end
end

# Utility methods for :blockarg nodes.
module Reek::AST::SexpExtensions::BlockargNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#69
  def block?; end
end

# source://reek//lib/reek/ast/sexp_extensions/send.rb#53
Reek::AST::SexpExtensions::CSendNode = Reek::AST::SexpExtensions::SendNode

# Utility methods for :case nodes.
module Reek::AST::SexpExtensions::CaseNode
  # source://reek//lib/reek/ast/sexp_extensions/case.rb#12
  def body_nodes(type, ignoring = T.unsafe(nil)); end

  # source://reek//lib/reek/ast/sexp_extensions/case.rb#8
  def condition; end

  # source://reek//lib/reek/ast/sexp_extensions/case.rb#18
  def else_body; end
end

# Utility methods for constant assignment (:casgn) nodes.
module Reek::AST::SexpExtensions::CasgnNode
  include ::Reek::AST::SexpExtensions::ConstantDefiningNodeBase

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/module.rb#103
  def defines_module?; end

  # source://reek//lib/reek/ast/sexp_extensions/module.rb#129
  def name; end

  # Sometimes we assign classes like:
  #
  # Foo = Class.new(Bar)
  #
  # This is mapped into the following expression:
  #
  # s(:casgn, nil :Foo,
  #   s(:send,
  #     s(:const, nil, :Class), :new,
  #     s(:const, nil, :Bar)
  #   )
  # )
  #
  # And we are only looking for s(:const, nil, :Bar)
  #
  # source://reek//lib/reek/ast/sexp_extensions/module.rb#123
  def superclass; end

  # there are two valid forms of the casgn sexp
  # (casgn <namespace> <name> <value>) and
  # (casgn <namespace> <name>) used in or-asgn and mlhs
  #
  # source = "class Hi; THIS ||= 3; end"
  # (class
  #   (const nil :Hi) nil
  #   (or-asgn
  #    (casgn nil :THIS)
  #    (int 3)))
  #
  # source://reek//lib/reek/ast/sexp_extensions/module.rb#143
  def value; end

  private

  # This is the right hand side of a constant
  # assignment.
  #
  # This can be simple:
  #
  # Foo = 23
  #
  # s(:casgn, nil, :Foo,
  #   s(:int, 23))
  #
  # In this cases we do not care and return nil.
  #
  # Or complicated:
  #
  # Iterator = Struct.new :exp do ... end
  #
  # s(:casgn, nil, :Iterator,
  #   s(:block,
  #     s(:send,
  #       s(:const, nil, :Struct), :new,
  #       s(:sym, :exp)
  #     ),
  #     s(:args),
  #     ...
  #   )
  # )
  #
  # In this cases we return the Struct.new part
  #
  # source://reek//lib/reek/ast/sexp_extensions/module.rb#178
  def constant_definition; end
end

# Utility methods for class definition (:class) nodes.
module Reek::AST::SexpExtensions::ClassNode
  include ::Reek::AST::SexpExtensions::ConstantDefiningNodeBase
  include ::Reek::AST::SexpExtensions::ModuleNodeBase

  # source://reek//lib/reek/ast/sexp_extensions/module.rb#96
  def superclass; end
end

# Utility methods for :const nodes.
module Reek::AST::SexpExtensions::ConstNode
  # TODO: name -> full_name, simple_name -> name
  #
  # source://reek//lib/reek/ast/sexp_extensions/constant.rb#9
  def name; end

  # source://reek//lib/reek/ast/sexp_extensions/constant.rb#21
  def namespace; end

  # source://reek//lib/reek/ast/sexp_extensions/constant.rb#17
  def simple_name; end
end

# Base module for utility methods for nodes that define constants: module
# definition, class definition and constant assignment.
module Reek::AST::SexpExtensions::ConstantDefiningNodeBase
  # The full name of the constant, including the name of any
  # module or class it is nested inside of.
  #
  # For example, given code like this:
  #
  #   module Foo
  #     class Bar::Baz
  #     end
  #   end
  #
  # The full name for the inner class will be 'Foo::Bar::Baz'. To return
  # the correct name, the name of the outer context has to be passed into
  # this method.
  #
  # @param outer [String] full name of the wrapping module or class
  # @return the module's full name
  #
  # source://reek//lib/reek/ast/sexp_extensions/module.rb#25
  def full_name(outer); end

  # The final section of the module or class name. For example, for a
  # module with name 'Foo::Bar' this will return 'Bar'; for a module with
  # name 'Foo' this will return 'Foo'.
  #
  # @return [String] the final section of the name
  #
  # source://reek//lib/reek/ast/sexp_extensions/module.rb#34
  def simple_name; end
end

# Utility methods for :cvar nodes.
module Reek::AST::SexpExtensions::CvarNode
  include ::Reek::AST::SexpExtensions::VariableBase
end

# source://reek//lib/reek/ast/sexp_extensions/variables.rb#41
Reek::AST::SexpExtensions::CvasgnNode = Reek::AST::SexpExtensions::CvarNode

# source://reek//lib/reek/ast/sexp_extensions/variables.rb#42
Reek::AST::SexpExtensions::CvdeclNode = Reek::AST::SexpExtensions::CvarNode

# Utility methods for :def nodes.
module Reek::AST::SexpExtensions::DefNode
  include ::Reek::AST::SexpExtensions::MethodNodeBase

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#48
  def argslist; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#52
  def body; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#60
  def depends_on_instance?; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#56
  def full_name(outer); end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#44
  def name; end
end

# Utility methods for :defs nodes.
module Reek::AST::SexpExtensions::DefsNode
  include ::Reek::AST::SexpExtensions::MethodNodeBase

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#77
  def argslist; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#81
  def body; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#90
  def depends_on_instance?; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#85
  def full_name(outer); end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#73
  def name; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#69
  def receiver; end
end

# Utility methods for :forward_arg nodes.
module Reek::AST::SexpExtensions::Forward_ArgNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#113
  def anonymous_splat?; end
end

# Utility methods for :forward_args nodes.
module Reek::AST::SexpExtensions::Forward_ArgsNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#102
  def anonymous_splat?; end
end

# Utility methods for :gvar nodes.
module Reek::AST::SexpExtensions::GvarNode
  include ::Reek::AST::SexpExtensions::VariableBase
end

# Utility methods for :if nodes.
module Reek::AST::SexpExtensions::IfNode
  # source://reek//lib/reek/ast/sexp_extensions/if.rb#33
  def body_nodes(type, ignoring = T.unsafe(nil)); end

  # @return [Reek::AST::Node] the condition that is associated with a conditional node.
  #   For instance, this code
  #
  #   if charlie(bravo) then delta end
  #
  #   would be parsed into this AST:
  #
  #   s(:if,
  #   s(:send, nil, :charlie,
  #   s(:lvar, :bravo)),
  #   s(:send, nil, :delta), nil)
  #
  #   so in this case we would return this
  #
  #   s(:send, nil, :charlie,
  #   s(:lvar, :bravo))
  #
  #   as condition.
  #
  # source://reek//lib/reek/ast/sexp_extensions/if.rb#28
  def condition; end
end

# Utility methods for :ivar nodes.
module Reek::AST::SexpExtensions::IvarNode
  include ::Reek::AST::SexpExtensions::VariableBase
end

# Utility methods for :ivasgn nodes.
module Reek::AST::SexpExtensions::IvasgnNode
  include ::Reek::AST::SexpExtensions::VariableBase
end

# Utility methods for :kwarg nodes.
module Reek::AST::SexpExtensions::KwargNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase
end

# Utility methods for :kwoptarg nodes.
module Reek::AST::SexpExtensions::KwoptargNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#60
  def optional_argument?; end
end

# Utility methods for :kwrestarg nodes.
module Reek::AST::SexpExtensions::KwrestargNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#87
  def anonymous_splat?; end
end

# Utility methods for :lambda nodes.
module Reek::AST::SexpExtensions::LambdaNode
  # source://reek//lib/reek/ast/sexp_extensions/lambda.rb#8
  def name; end
end

# Base module for utility methods for :and and :or nodes.
module Reek::AST::SexpExtensions::LogicOperatorBase
  # source://reek//lib/reek/ast/sexp_extensions/logical_operators.rb#12
  def body_nodes(type, ignoring = T.unsafe(nil)); end

  # source://reek//lib/reek/ast/sexp_extensions/logical_operators.rb#8
  def condition; end
end

# Utility methods for :lvar nodes.
module Reek::AST::SexpExtensions::LvarNode
  include ::Reek::AST::SexpExtensions::VariableBase

  # source://reek//lib/reek/ast/sexp_extensions/variables.rb#8
  def var_name; end
end

# source://reek//lib/reek/ast/sexp_extensions/variables.rb#40
Reek::AST::SexpExtensions::LvasgnNode = Reek::AST::SexpExtensions::LvarNode

# Base module for utility methods for :def and :defs nodes.
module Reek::AST::SexpExtensions::MethodNodeBase
  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#12
  def arg_names; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#8
  def arguments; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#32
  def body_nodes(types, ignoring = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#28
  def ends_with_bang?; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#24
  def name_without_bang; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#20
  def parameter_names; end

  # source://reek//lib/reek/ast/sexp_extensions/methods.rb#16
  def parameters; end
end

# Utility methods for :mlhs nodes.
module Reek::AST::SexpExtensions::MlhsNode
  include ::Reek::AST::SexpExtensions::NestedAssignables
end

# Utility methods for module definition (:module) nodes.
module Reek::AST::SexpExtensions::ModuleNode
  include ::Reek::AST::SexpExtensions::ConstantDefiningNodeBase
  include ::Reek::AST::SexpExtensions::ModuleNodeBase
end

# Base module for utility methods for module nodes.
module Reek::AST::SexpExtensions::ModuleNodeBase
  include ::Reek::AST::SexpExtensions::ConstantDefiningNodeBase

  # In the AST, the set of children of a module that a human might identify
  # is coded in three different ways.
  #
  # If there are no children, the last element of the module node is nil,
  # like so:
  #
  #   s(:class,
  #     s(:const, nil, :C),
  #     nil,
  #     nil)
  #
  # If there is one child, the last element of the module node is that
  # child, like so:
  #
  #   s(:class,
  #     s(:const, nil, :C),
  #     nil,
  #     s(:def, :f, s(:args), nil))
  #
  # If there is more than one child, those are wrapped as children in a
  # node of type :begin, like so:
  #
  #   s(:class,
  #     s(:const, nil, :Alfa),
  #     nil,
  #     s(:begin,
  #       s(:def, :bravo, s(:args), nil),
  #       s(:class, s(:const, nil, :Charlie), nil, nil)))
  #
  # This method unifies those three ways to avoid having to handle them
  # differently.
  #
  # @return an array of directly visible children of the module
  #
  # source://reek//lib/reek/ast/sexp_extensions/module.rb#81
  def direct_children; end

  # source://reek//lib/reek/ast/sexp_extensions/module.rb#43
  def name; end
end

# Base module for utility methods for nodes that can contain argument
# nodes nested through :mlhs nodes.
module Reek::AST::SexpExtensions::NestedAssignables
  # source://reek//lib/reek/ast/sexp_extensions/nested_assignables.rb#9
  def components; end
end

# source://reek//lib/reek/ast/sexp_extensions/send.rb#52
Reek::AST::SexpExtensions::Op_AsgnNode = Reek::AST::SexpExtensions::SendNode

# Utility methods for :optarg nodes.
module Reek::AST::SexpExtensions::OptargNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#51
  def optional_argument?; end
end

# Utility methods for :or nodes.
module Reek::AST::SexpExtensions::OrNode
  include ::Reek::AST::SexpExtensions::LogicOperatorBase
end

# Utility methods for :restarg nodes.
module Reek::AST::SexpExtensions::RestargNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/arguments.rb#78
  def anonymous_splat?; end
end

# Utility methods for :self nodes.
module Reek::AST::SexpExtensions::SelfNode
  # source://reek//lib/reek/ast/sexp_extensions/self.rb#8
  def name; end
end

# Utility methods for :send nodes.
module Reek::AST::SexpExtensions::SendNode
  # source://reek//lib/reek/ast/sexp_extensions/send.rb#18
  def args; end

  # Handles the case where we create an attribute writer via:
  # attr :foo, true
  #
  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/send.rb#47
  def attr_with_writable_flag?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/send.rb#40
  def attribute_writer?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/send.rb#26
  def module_creation_call?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/send.rb#30
  def module_creation_receiver?; end

  # source://reek//lib/reek/ast/sexp_extensions/send.rb#14
  def name; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/ast/sexp_extensions/send.rb#36
  def object_creation_call?; end

  # source://reek//lib/reek/ast/sexp_extensions/send.rb#22
  def participants; end

  # source://reek//lib/reek/ast/sexp_extensions/send.rb#10
  def receiver; end
end

# source://reek//lib/reek/ast/sexp_extensions/send.rb#8
Reek::AST::SexpExtensions::SendNode::ATTR_DEFN_METHODS = T.let(T.unsafe(nil), Array)

# Utility methods for :shadowarg nodes.
module Reek::AST::SexpExtensions::ShadowargNode
  include ::Reek::AST::SexpExtensions::ArgNodeBase
end

# Utility methods for :super nodes.
module Reek::AST::SexpExtensions::SuperNode
  # source://reek//lib/reek/ast/sexp_extensions/super.rb#8
  def name; end
end

# Utility methods for :sym nodes.
module Reek::AST::SexpExtensions::SymNode
  # source://reek//lib/reek/ast/sexp_extensions/symbols.rb#12
  def full_name(outer); end

  # source://reek//lib/reek/ast/sexp_extensions/symbols.rb#8
  def name; end
end

# Base module for utility methods for nodes representing variables.
module Reek::AST::SexpExtensions::VariableBase
  # source://reek//lib/reek/ast/sexp_extensions/variables.rb#8
  def name; end
end

# Utility methods for :when nodes.
module Reek::AST::SexpExtensions::WhenNode
  # source://reek//lib/reek/ast/sexp_extensions/when.rb#12
  def body; end

  # source://reek//lib/reek/ast/sexp_extensions/when.rb#8
  def condition_list; end
end

# Utility methods for :yield nodes.
module Reek::AST::SexpExtensions::YieldNode
  # source://reek//lib/reek/ast/sexp_extensions/yield.rb#8
  def args; end
end

# source://reek//lib/reek/ast/sexp_extensions/super.rb#13
Reek::AST::SexpExtensions::ZsuperNode = Reek::AST::SexpExtensions::SuperNode

module Reek::CLI; end

# CLI silencer
module Reek::CLI::Silencer
  private

  # source://reek//lib/reek/cli/silencer.rb#12
  def silently; end

  # source://reek//lib/reek/cli/silencer.rb#27
  def without_warnings; end

  class << self
    # source://reek//lib/reek/cli/silencer.rb#12
    def silently; end

    # source://reek//lib/reek/cli/silencer.rb#27
    def without_warnings; end
  end
end

# A comment header from an abstract syntax tree; found directly above
# module, class and method definitions.
class Reek::CodeComment
  # @param comment [String] the original comment as found in the source code
  # @param line [Integer] start of the expression the comment belongs to
  # @param source [String] Path to source file or "string"
  # @return [CodeComment] a new instance of CodeComment
  #
  # source://reek//lib/reek/code_comment.rb#34
  def initialize(comment:, line: T.unsafe(nil), source: T.unsafe(nil)); end

  # Returns the value of attribute config.
  #
  # source://reek//lib/reek/code_comment.rb#27
  def config; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/code_comment.rb#52
  def descriptive?; end

  private

  # @raise [Errors::LegacyCommentSeparatorError]
  #
  # source://reek//lib/reek/code_comment.rb#67
  def escalate_legacy_separator(separator); end

  # Returns the value of attribute line.
  #
  # source://reek//lib/reek/code_comment.rb#58
  def line; end

  # Returns the value of attribute original_comment.
  #
  # source://reek//lib/reek/code_comment.rb#58
  def original_comment; end

  # source://reek//lib/reek/code_comment.rb#60
  def sanitized_comment; end

  # Returns the value of attribute source.
  #
  # source://reek//lib/reek/code_comment.rb#58
  def source; end
end

# source://reek//lib/reek/code_comment.rb#17
Reek::CodeComment::CONFIGURATION_REGEX = T.let(T.unsafe(nil), Regexp)

# A typical configuration via code comment looks like this:
#
#   :reek:DuplicateMethodCall { enabled: false }
#
# There are a lot of ways a user can introduce some errors here:
#
# 1.) Unknown smell detector
# 2.) Garbage in the detector configuration like { thats: a: bad: config }
# 3.) Unknown configuration keys (e.g. by doing a simple typo: "exclude" vs. "exlude" )
# 4.) Bad data types given as values for those keys
# This class validates [1], [2] and [3] at the moment but will also validate
# [4] in the future.
class Reek::CodeComment::CodeCommentValidator
  # @param detector_name [String] the detector class that was parsed out of the original
  #   comment, e.g. "DuplicateMethodCall" or "UnknownSmellDetector"
  # @param original_comment [String] the original comment as found in the source code
  # @param line [Integer] start of the expression the comment belongs to
  # @param source [String] path to source file or "string"
  # @param options [String] the configuration options as String for the detector that were
  #   extracted from the original comment
  # @return [CodeCommentValidator] a new instance of CodeCommentValidator
  #
  # source://reek//lib/reek/code_comment.rb#99
  def initialize(detector_name:, original_comment:, line:, source:, options:); end

  # source://reek//lib/reek/code_comment.rb#118
  def parsed_options; end

  # Method can raise the following errors:
  #   * Errors::LegacyCommentSeparatorError
  #   * Errors::BadDetectorInCommentError
  #   * Errors::GarbageDetectorConfigurationInCommentError
  #   * Errors::BadDetectorConfigurationKeyInCommentError
  #
  # @return [undefined]
  #
  # source://reek//lib/reek/code_comment.rb#114
  def validate; end

  private

  # @return [String] all keys from the code comment that look bad
  #
  # source://reek//lib/reek/code_comment.rb#177
  def configuration_keys_difference; end

  # source://reek//lib/reek/code_comment.rb#152
  def detector_class; end

  # Returns the value of attribute detector_name.
  #
  # source://reek//lib/reek/code_comment.rb#135
  def detector_name; end

  # @raise [Errors::BadDetectorConfigurationKeyInCommentError]
  #
  # source://reek//lib/reek/code_comment.rb#142
  def escalate_unknown_configuration_key; end

  # @return [Set] the configuration keys that are found in the code comment
  #
  # source://reek//lib/reek/code_comment.rb#172
  def given_configuration_keys; end

  # @return [Boolean] all keys in code comment are applicable to the detector in question
  #
  # source://reek//lib/reek/code_comment.rb#167
  def given_keys_legit?; end

  # @return [Boolean] comment uses legacy three-colon format
  #
  # source://reek//lib/reek/code_comment.rb#162
  def legacy_format?; end

  # Returns the value of attribute line.
  #
  # source://reek//lib/reek/code_comment.rb#135
  def line; end

  # Returns the value of attribute options.
  #
  # source://reek//lib/reek/code_comment.rb#135
  def options; end

  # Returns the value of attribute original_comment.
  #
  # source://reek//lib/reek/code_comment.rb#135
  def original_comment; end

  # Returns the value of attribute separator.
  #
  # source://reek//lib/reek/code_comment.rb#135
  def separator; end

  # Returns the value of attribute source.
  #
  # source://reek//lib/reek/code_comment.rb#135
  def source; end

  # @return [Set] all keys that are legit for the given detector
  #
  # source://reek//lib/reek/code_comment.rb#184
  def valid_detector_keys; end
end

# source://reek//lib/reek/code_comment.rb#24
Reek::CodeComment::DISABLE_DETECTOR_CONFIGURATION = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/code_comment.rb#25
Reek::CodeComment::MINIMUM_CONTENT_LENGTH = T.let(T.unsafe(nil), Integer)

# Matches '#', newlines and > 1 whitespaces.
#
# source://reek//lib/reek/code_comment.rb#23
Reek::CodeComment::SANITIZE_REGEX = T.let(T.unsafe(nil), Regexp)

module Reek::Configuration; end

# Reek's application configuration.
class Reek::Configuration::AppConfiguration
  include ::Reek::Configuration::ConfigurationValidator

  # @return [AppConfiguration] a new instance of AppConfiguration
  #
  # source://reek//lib/reek/configuration/app_configuration.rb#86
  def initialize(values: T.unsafe(nil)); end

  # Returns the directive for a given directory.
  #
  # @param source_via [String] the source of the code inspected
  # @return [Hash] the directory directive for the source with the default directive
  #   reverse-merged into it.
  #
  # source://reek//lib/reek/configuration/app_configuration.rb#64
  def directive_for(source_via); end

  # source://reek//lib/reek/configuration/app_configuration.rb#73
  def load_values(values); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/configuration/app_configuration.rb#69
  def path_excluded?(path); end

  private

  # source://reek//lib/reek/configuration/app_configuration.rb#98
  def default_directive; end

  # Sets the attribute default_directive
  #
  # @param value the value to set the attribute default_directive to.
  #
  # source://reek//lib/reek/configuration/app_configuration.rb#92
  def default_directive=(_arg0); end

  # source://reek//lib/reek/configuration/app_configuration.rb#94
  def directory_directives; end

  # Sets the attribute directory_directives
  #
  # @param value the value to set the attribute directory_directives to.
  #
  # source://reek//lib/reek/configuration/app_configuration.rb#92
  def directory_directives=(_arg0); end

  # source://reek//lib/reek/configuration/app_configuration.rb#102
  def excluded_paths; end

  # Sets the attribute excluded_paths
  #
  # @param value the value to set the attribute excluded_paths to.
  #
  # source://reek//lib/reek/configuration/app_configuration.rb#92
  def excluded_paths=(_arg0); end

  class << self
    # source://reek//lib/reek/configuration/app_configuration.rb#54
    def default; end

    # Instantiate a configuration via the default path.
    #
    # @return [AppConfiguration]
    #
    # source://reek//lib/reek/configuration/app_configuration.rb#36
    def from_default_path; end

    # Instantiate a configuration by passing everything in.
    #
    # Loads the configuration from a hash of the form that is loaded from a
    # +.reek+ config file.
    #
    # @param hash [Hash] The configuration hash to load.
    # @return [AppConfiguration]
    #
    # source://reek//lib/reek/configuration/app_configuration.rb#50
    def from_hash(hash); end

    # Instantiate a configuration via the given path.
    #
    # @param path [Pathname] the path to the config file.
    # @return [AppConfiguration]
    #
    # source://reek//lib/reek/configuration/app_configuration.rb#26
    def from_path(path); end
  end
end

# Responsible for converting marked strings coming from the outside world
# into proper regexes.
class Reek::Configuration::ConfigurationConverter
  include ::Reek::Configuration::ConfigurationValidator

  # @param configuration [Hash] e.g.
  #
  #   detectors => {
  #   "UnusedPrivateMethod" => {"exclude"=>["/exclude regexp/"]},
  #   "UncommunicativeMethodName"=>{"reject"=>["reject name"], "accept"=>["accept name"]
  #   },
  #   directories => {
  #   "app/controllers" => {
  #   "UnusedPrivateMethod" => {"exclude"=>["/exclude regexp/"]},
  #   "UncommunicativeMethodName"=>{"reject"=>["reject name"], "accept"=>["accept name"]}
  #   }
  #   }
  # @return [ConfigurationConverter] a new instance of ConfigurationConverter
  #
  # source://reek//lib/reek/configuration/configuration_converter.rb#26
  def initialize(configuration); end

  # Returns the value of attribute configuration.
  #
  # source://reek//lib/reek/configuration/configuration_converter.rb#12
  def configuration; end

  # Converts all marked strings across the whole configuration to regexes.
  #
  # @return [Hash]
  #
  # source://reek//lib/reek/configuration/configuration_converter.rb#33
  def convert; end

  private

  # @param detector_configuration [Hash] e.g.
  #   { "UnusedPrivateMethod" => {"exclude"=>["/exclude regexp/"] }
  # @return [Array] all the attributes from the detector configuration that potentially contain regexes.
  #   Using this example above this would just be "exclude".
  #
  # source://reek//lib/reek/configuration/configuration_converter.rb#63
  def convertible_attributes(detector_configuration); end

  # @param value [String] String that is potentially marked as regex, e.g. "/foobar/".
  # @return [Bool] if the string in question is marked as regex.
  #
  # source://reek//lib/reek/configuration/configuration_converter.rb#46
  def marked_as_regex?(value); end

  # Iterates over our detector configuration and converts all marked strings into regexes.
  #
  # @return nil
  #
  # source://reek//lib/reek/configuration/configuration_converter.rb#73
  def strings_to_regexes_for_detectors; end

  # Iterates over our directory configuration and converts all marked strings into regexes.
  #
  # @return nil
  #
  # source://reek//lib/reek/configuration/configuration_converter.rb#93
  def strings_to_regexes_for_directories; end

  # @param value [value] String that is potentially marked as regex, e.g. "/foobar/".
  # @return [Regexp] e.g. /foobar/.
  #
  # source://reek//lib/reek/configuration/configuration_converter.rb#53
  def to_regex(value); end
end

# source://reek//lib/reek/configuration/configuration_converter.rb#10
Reek::Configuration::ConfigurationConverter::REGEXABLE_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# ConfigurationFileFinder is responsible for finding Reek's configuration.
#
# There are 3 ways of passing `reek` a configuration file:
# 1. Using the cli "-c" switch
# 2. Having a file .reek.yml either in your current working
#    directory or in a parent directory
# 3. Having a file .reek.yml in your HOME directory
#
# The order in which ConfigurationFileFinder tries to find such a
# configuration file is exactly like above.
module Reek::Configuration::ConfigurationFileFinder
  extend ::Reek::Configuration::ConfigurationValidator

  class << self
    # Tries to find a configuration file via:
    #   * given path (e.g. via cli switch)
    #   * ascending down from the current directory
    #   * looking into the home directory
    #
    # @return [File|nil]
    #
    # source://reek//lib/reek/configuration/configuration_file_finder.rb#44
    def find(path: T.unsafe(nil), current: T.unsafe(nil), home: T.unsafe(nil)); end

    # Finds and loads a configuration file from a given path.
    #
    # @return [Hash]
    #
    # source://reek//lib/reek/configuration/configuration_file_finder.rb#31
    def find_and_load(path: T.unsafe(nil)); end

    # Loads a configuration file from a given path.
    # Raises on invalid data.
    #
    # @param path [String]
    # @return [Hash]
    #
    # source://reek//lib/reek/configuration/configuration_file_finder.rb#56
    def load_from_file(path); end

    private

    # Recursively traverse directories down to find a configuration file.
    #
    # @return [File|nil]
    #
    # source://reek//lib/reek/configuration/configuration_file_finder.rb#76
    def find_by_dir(start); end

    # Checks a given directory for a configuration file and returns it.
    #
    # @return [File|nil]
    #
    # source://reek//lib/reek/configuration/configuration_file_finder.rb#89
    def find_in_dir(dir); end
  end
end

# source://reek//lib/reek/configuration/configuration_file_finder.rb#22
Reek::Configuration::ConfigurationFileFinder::DEFAULT_FILE_NAME = T.let(T.unsafe(nil), String)

# Configuration validator module.
module Reek::Configuration::ConfigurationValidator
  private

  # source://reek//lib/reek/configuration/configuration_validator.rb#21
  def key_to_smell_detector(key); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/configuration/configuration_validator.rb#14
  def smell_type?(key); end

  # @yield [directory]
  #
  # source://reek//lib/reek/configuration/configuration_validator.rb#25
  def with_valid_directory(path); end
end

# Hash extension for the default directive.
module Reek::Configuration::DefaultDirective
  include ::Reek::Configuration::ConfigurationValidator

  # Adds the configuration for detectors as default directive.
  #
  # @param detectors_configuration [Hash] the configuration e.g.:
  #   {
  #   :IrresponsibleModule => {:enabled=>false},
  #   :Attribute => {:enabled=>true}
  #   }
  # @return [self]
  #
  # source://reek//lib/reek/configuration/default_directive.rb#22
  def add(detectors_configuration); end
end

# Hash extension for directory directives.
module Reek::Configuration::DirectoryDirectives
  include ::Reek::Configuration::ConfigurationValidator

  # Adds a directive and returns self.
  #
  # @param directory_config [Hash] the configuration e.g.:
  #   {
  #   "samples/two_smelly_files" => {:IrresponsibleModule=>{:enabled=>false}},
  #   "samples/three_clean_files" => {:Attribute=>{:enabled=>true}}
  #   }
  # @return [self]
  #
  # source://reek//lib/reek/configuration/directory_directives.rb#38
  def add(directory_config); end

  # Returns the directive for a given source.
  #
  # @param source_via [String] the source of the code inspected
  # @return [Hash | nil] the configuration for the source or nil
  #
  # source://reek//lib/reek/configuration/directory_directives.rb#18
  def directive_for(source_via); end

  private

  # source://reek//lib/reek/configuration/directory_directives.rb#54
  def best_match_for(source_base_dir); end

  # source://reek//lib/reek/configuration/directory_directives.rb#93
  def error_message_for_invalid_smell_type(klass); end

  # Transform a glob pattern to a regexp.
  #
  # It changes:
  # - /** to .*,
  # - ** to .*,
  # - * to [^\/]*.
  #
  # source://reek//lib/reek/configuration/directory_directives.rb#75
  def glob_to_regexp(glob); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/configuration/directory_directives.rb#62
  def match?(source_base_dir, pathname); end
end

# Array extension for excluded paths.
module Reek::Configuration::ExcludedPaths
  include ::Reek::Configuration::ConfigurationValidator

  # @param paths [String]
  # @return [undefined]
  #
  # source://reek//lib/reek/configuration/excluded_paths.rb#16
  def add(paths); end
end

# Schema validator module.
class Reek::Configuration::SchemaValidator
  # @return [SchemaValidator] a new instance of SchemaValidator
  #
  # source://reek//lib/reek/configuration/schema_validator.rb#16
  def initialize(configuration); end

  # @raise [Errors::ConfigFileError]
  #
  # source://reek//lib/reek/configuration/schema_validator.rb#24
  def validate; end

  private

  # :reek:UtilityFunction
  #
  # source://reek//lib/reek/configuration/schema_validator.rb#34
  def error_message(errors); end
end

# source://reek//lib/reek/configuration/schema_validator.rb#14
Reek::Configuration::SchemaValidator::SCHEMA_FILE_PATH = T.let(T.unsafe(nil), String)

module Reek::Context; end

# A context wrapper for attribute definitions found in a syntax tree.
class Reek::Context::AttributeContext < ::Reek::Context::CodeContext
  # @return [AttributeContext] a new instance of AttributeContext
  #
  # source://reek//lib/reek/context/attribute_context.rb#14
  def initialize(exp, send_expression); end

  # source://reek//lib/reek/context/attribute_context.rb#28
  def apply_current_visibility(current_visibility); end

  # source://reek//lib/reek/context/attribute_context.rb#20
  def full_comment; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/attribute_context.rb#24
  def instance_method?; end

  # Returns the value of attribute visibility.
  #
  # source://reek//lib/reek/context/attribute_context.rb#12
  def visibility; end

  # Sets the attribute visibility
  #
  # @param value the value to set the attribute visibility to.
  #
  # source://reek//lib/reek/context/attribute_context.rb#12
  def visibility=(_arg0); end

  private

  # Returns the value of attribute send_expression.
  #
  # source://reek//lib/reek/context/attribute_context.rb#34
  def send_expression; end
end

# A context wrapper for any class found in a syntax tree.
class Reek::Context::ClassContext < ::Reek::Context::ModuleContext; end

# Superclass for all types of source code context. Each instance represents
# a code element of some kind, and each provides behaviour relevant to that
# code element. CodeContexts form a tree in the same way the code does,
# with each context holding a reference to a unique outer context.
class Reek::Context::CodeContext
  include ::Enumerable
  extend ::Forwardable

  # Initializes a new CodeContext.
  #
  # @param exp [Reek::AST::Node] The code described by this context
  # @return [CodeContext] a new instance of CodeContext
  #
  # source://reek//lib/reek/context/code_context.rb#29
  def initialize(exp); end

  # Register a context as a child context of this context. This is
  # generally used by a child context to register itself with its parent.
  #
  # @param child [CodeContext] the child context to register
  #
  # source://reek//lib/reek/context/code_context.rb#108
  def append_child_context(child); end

  # source://reek//lib/reek/context/code_context.rb#160
  def apply_current_visibility(_current_visibility); end

  # Returns the value of attribute children.
  #
  # source://reek//lib/reek/context/code_context.rb#24
  def children; end

  # source://reek//lib/reek/context/code_context.rb#143
  def config_for(detector_class); end

  # Iterate over `self` and child contexts.
  # The main difference (among others) to `local_nodes` is that we are traversing
  # `CodeContexts` here, not AST nodes (see `Reek::AST::Node`).
  #
  # @return [Enumerator]
  # @yield block that is executed for every node.
  #
  # source://reek//lib/reek/context/code_context.rb#53
  def each(&block); end

  # Returns the value of attribute exp.
  #
  # source://reek//lib/reek/context/code_context.rb#24
  def exp; end

  # source://reek//lib/reek/context/code_context.rb#139
  def full_name; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/code_context.rb#156
  def instance_method?; end

  # Iterate over each AST node (see `Reek::AST::Node`) of a given type for the current expression.
  #
  # @param type [Symbol] the type of the nodes we are looking for, e.g. :defs.
  # @yield block that is executed for every node.
  #
  # source://reek//lib/reek/context/code_context.rb#41
  def local_nodes(type, ignored = T.unsafe(nil), &blk); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/code_context.rb#131
  def matches?(candidates); end

  # source://forwardable/1.3.2/forwardable.rb#229
  def name(*args, **_arg1, &block); end

  # source://reek//lib/reek/context/code_context.rb#148
  def number_of_statements; end

  # Returns the value of attribute parent.
  #
  # source://reek//lib/reek/context/code_context.rb#24
  def parent; end

  # source://reek//lib/reek/context/code_context.rb#115
  def record_call_to(exp); end

  # source://reek//lib/reek/context/code_context.rb#127
  def record_use_of_self; end

  # Link the present context to its parent.
  #
  # For example, given the following code:
  #
  #   class Omg
  #     def foo(x)
  #       puts x
  #     end
  #   end
  #
  # The {ContextBuilder} object first instantiates a {RootContext}, which has no parent.
  #
  # Next, it instantiates a {ModuleContext}, with +exp+ looking like this:
  #
  #  (class
  #    (const nil :Omg) nil
  #    (def :foo
  #      (args
  #        (arg :x))
  #      (send nil :puts
  #        (lvar :x))))
  #
  # It will then call #register_with_parent on the {ModuleContext}, passing
  # in the parent {RootContext}.
  #
  # Finally, {ContextBuilder} will instantiate a {MethodContext}. This time,
  # +exp+ is:
  #
  #   (def :foo
  #     (args
  #       (arg :x))
  #     (send nil :puts
  #       (lvar :x)))
  #
  # Then it will call #register_with_parent on the {MethodContext}, passing
  # in the parent {ModuleContext}.
  #
  # @param parent [Reek::AST::Node] The parent context of the code described by this context
  #
  # source://reek//lib/reek/context/code_context.rb#100
  def register_with_parent(parent); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/code_context.rb#152
  def singleton_method?; end

  # Returns the value of attribute statement_counter.
  #
  # source://reek//lib/reek/context/code_context.rb#24
  def statement_counter; end

  # source://forwardable/1.3.2/forwardable.rb#229
  def type(*args, **_arg1, &block); end

  private

  # source://reek//lib/reek/context/code_context.rb#168
  def configuration_via_code_commment; end

  # source://reek//lib/reek/context/code_context.rb#174
  def full_comment; end

  # source://reek//lib/reek/context/code_context.rb#178
  def parent_config_for(detector_class); end

  # Returns the value of attribute refs.
  #
  # source://reek//lib/reek/context/code_context.rb#166
  def refs; end
end

# Semi-transparent context to represent a metaclass while building the
# context tree. This context will not be part of the resulting tree, but
# will track context and visibility separately while building is in
# progress.
class Reek::Context::GhostContext < ::Reek::Context::ModuleContext
  # source://reek//lib/reek/context/ghost_context.rb#19
  def append_child_context(child); end

  # Return the correct class for child attribute contexts. For
  # GhostContext, this is the class that represents singleton attributes.
  #
  # source://reek//lib/reek/context/ghost_context.rb#34
  def attribute_context_class; end

  # Returns the value of attribute children.
  #
  # source://reek//lib/reek/context/ghost_context.rb#13
  def children; end

  # Return the correct class for child method contexts (representing nodes
  # of type `:def`). For GhostContext, this is the class that represents
  # singleton methods.
  #
  # source://reek//lib/reek/context/ghost_context.rb#28
  def method_context_class; end

  # source://reek//lib/reek/context/ghost_context.rb#44
  def record_use_of_self; end

  # source://reek//lib/reek/context/ghost_context.rb#15
  def register_with_parent(parent); end

  # source://reek//lib/reek/context/ghost_context.rb#48
  def statement_counter; end

  # source://reek//lib/reek/context/ghost_context.rb#38
  def track_visibility(visibility, names); end
end

# A context wrapper for any method definition found in a syntax tree.
class Reek::Context::MethodContext < ::Reek::Context::CodeContext
  # @return [MethodContext] a new instance of MethodContext
  #
  # source://reek//lib/reek/context/method_context.rb#15
  def initialize(exp, parent_exp); end

  # source://reek//lib/reek/context/method_context.rb#68
  def apply_current_visibility(current_visibility); end

  # source://reek//lib/reek/context/method_context.rb#51
  def default_assignments; end

  # source://reek//lib/reek/context/method_context.rb#80
  def full_comment; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/method_context.rb#64
  def instance_method?; end

  # source://reek//lib/reek/context/method_context.rb#56
  def method_context_class; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/method_context.rb#72
  def module_function?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/method_context.rb#76
  def non_public_visibility?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/method_context.rb#21
  def references_self?; end

  # Returns the value of attribute refs.
  #
  # source://reek//lib/reek/context/method_context.rb#13
  def refs; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/method_context.rb#60
  def singleton_method?; end

  # source://reek//lib/reek/context/method_context.rb#39
  def unused_params; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/method_context.rb#25
  def uses_param?(param); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/method_context.rb#47
  def uses_super_with_implicit_arguments?; end

  # Returns the value of attribute visibility.
  #
  # source://reek//lib/reek/context/method_context.rb#12
  def visibility; end

  # Sets the attribute visibility
  #
  # @param value the value to set the attribute visibility to.
  #
  # source://reek//lib/reek/context/method_context.rb#12
  def visibility=(_arg0); end

  private

  # Returns the value of attribute parent_exp.
  #
  # source://reek//lib/reek/context/method_context.rb#90
  def parent_exp; end
end

# A context wrapper for any module found in a syntax tree.
class Reek::Context::ModuleContext < ::Reek::Context::CodeContext
  # @return [ModuleContext] a new instance of ModuleContext
  #
  # source://reek//lib/reek/context/module_context.rb#16
  def initialize(exp); end

  # Register a child context. The child's parent context should be equal to
  # the current context.
  #
  # This makes the current context responsible for setting the child's
  # visibility.
  #
  # @param child [CodeContext] the child context to register
  #
  # source://reek//lib/reek/context/module_context.rb#28
  def append_child_context(child); end

  # Return the correct class for child attribute contexts. For
  # ModuleContext, this is the class that represents instance attributes.
  #
  # source://reek//lib/reek/context/module_context.rb#42
  def attribute_context_class; end

  # source://reek//lib/reek/context/module_context.rb#46
  def defined_instance_methods(visibility: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/module_context.rb#69
  def descriptively_commented?; end

  # source://reek//lib/reek/context/module_context.rb#52
  def instance_method_calls; end

  # source://reek//lib/reek/context/module_context.rb#58
  def instance_method_names_via_to_call; end

  # Return the correct class for child method contexts (representing nodes
  # of type `:def`). For ModuleContext, this is the class that represents
  # instance methods.
  #
  # source://reek//lib/reek/context/module_context.rb#36
  def method_context_class; end

  # A namespace module is a module (or class) that is only there for namespacing
  # purposes, and thus contains only nested constants, modules or classes.
  #
  # However, if the module is empty, it is not considered a namespace module.
  #
  # @return [Boolean] true if the module is a namespace module
  #
  # source://reek//lib/reek/context/module_context.rb#83
  def namespace_module?; end

  # @deprecated use `defined_instance_methods` instead
  #
  # source://reek//lib/reek/context/module_context.rb#65
  def node_instance_methods; end

  # source://reek//lib/reek/context/module_context.rb#90
  def track_visibility(visibility, names); end

  # Returns the value of attribute visibility_tracker.
  #
  # source://reek//lib/reek/context/module_context.rb#14
  def visibility_tracker; end

  private

  # source://reek//lib/reek/context/module_context.rb#101
  def instance_method_children; end

  # source://reek//lib/reek/context/module_context.rb#105
  def singleton_method_children; end
end

# source://reek//lib/reek/context/module_context.rb#73
Reek::Context::ModuleContext::CONSTANT_SEXP_TYPES = T.let(T.unsafe(nil), Array)

# A context wrapper for any refinement blocks found in a syntax tree.
class Reek::Context::RefinementContext < ::Reek::Context::ModuleContext
  # source://reek//lib/reek/context/refinement_context.rb#11
  def full_name; end
end

# A context wrapper representing the root of an abstract syntax tree.
class Reek::Context::RootContext < ::Reek::Context::CodeContext
  # source://reek//lib/reek/context/root_context.rb#16
  def full_name; end

  # Return the correct class for child method contexts (representing nodes
  # of type `:def`). For RootContext, this is the class that represents
  # instance methods.
  #
  # source://reek//lib/reek/context/root_context.rb#23
  def method_context_class; end

  # source://reek//lib/reek/context/root_context.rb#12
  def type; end
end

# A context wrapper for method calls found in a syntax tree.
class Reek::Context::SendContext < ::Reek::Context::CodeContext
  # @return [SendContext] a new instance of SendContext
  #
  # source://reek//lib/reek/context/send_context.rb#13
  def initialize(exp, name); end

  # source://reek//lib/reek/context/send_context.rb#18
  def method_name_called_to_call; end

  # Returns the value of attribute name.
  #
  # source://reek//lib/reek/context/send_context.rb#11
  def name; end
end

# A context wrapper for any singleton attribute definition found in a
# syntax tree.
class Reek::Context::SingletonAttributeContext < ::Reek::Context::AttributeContext
  # @return [Boolean]
  #
  # source://reek//lib/reek/context/singleton_attribute_context.rb#12
  def instance_method?; end
end

# A context wrapper for any singleton method definition found in a syntax tree.
class Reek::Context::SingletonMethodContext < ::Reek::Context::MethodContext
  # source://reek//lib/reek/context/singleton_method_context.rb#28
  def apply_current_visibility(current_visibility); end

  # Was this singleton method defined with an instance method-like syntax?
  #
  # @return [Boolean]
  #
  # source://reek//lib/reek/context/singleton_method_context.rb#24
  def defined_as_instance_method?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/singleton_method_context.rb#15
  def instance_method?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/singleton_method_context.rb#19
  def module_function?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context/singleton_method_context.rb#11
  def singleton_method?; end
end

# Responsible for counting the statements in a `CodeContext`.
class Reek::Context::StatementCounter
  # @return [StatementCounter] a new instance of StatementCounter
  #
  # source://reek//lib/reek/context/statement_counter.rb#11
  def initialize; end

  # source://reek//lib/reek/context/statement_counter.rb#19
  def decrease_by(number); end

  # source://reek//lib/reek/context/statement_counter.rb#15
  def increase_by(sexp); end

  # Returns the value of attribute value.
  #
  # source://reek//lib/reek/context/statement_counter.rb#9
  def value; end

  private

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://reek//lib/reek/context/statement_counter.rb#25
  def value=(_arg0); end
end

# Responsible for tracking visibilities in regards to CodeContexts.
class Reek::Context::VisibilityTracker
  # @return [VisibilityTracker] a new instance of VisibilityTracker
  #
  # source://reek//lib/reek/context/visibility_tracker.rb#10
  def initialize; end

  # Sets the visibility of a CodeContext to the tracked visibility.
  #
  # @param context [CodeContext]
  #
  # source://reek//lib/reek/context/visibility_tracker.rb#59
  def apply_visibility(context); end

  # Handle the effects of a singleton visibility modifier. These can only
  # be used to modify existing children.
  #
  # @example
  #   track_singleton_visibility children, :private_class_method,
  #   [:hide_me, :implementation_detail]
  # @param children [Array<CodeContext>]
  # @param visibility [Symbol]
  # @param names [Array<Symbol>]
  #
  # source://reek//lib/reek/context/visibility_tracker.rb#46
  def track_singleton_visibility(children:, visibility:, names:); end

  # Handle the effects of a visibility modifier.
  #
  # @example Modifying the visibility of existing children
  #   track_visibility children, :private, [:hide_me, :implementation_detail]
  # @param children [Array<CodeContext>]
  # @param visibility [Symbol]
  # @param names [Array<Symbol>]
  #
  # source://reek//lib/reek/context/visibility_tracker.rb#23
  def track_visibility(children:, visibility:, names:); end

  private

  # Returns the value of attribute tracked_visibility.
  #
  # source://reek//lib/reek/context/visibility_tracker.rb#65
  def tracked_visibility; end

  # Sets the attribute tracked_visibility
  #
  # @param value the value to set the attribute tracked_visibility to.
  #
  # source://reek//lib/reek/context/visibility_tracker.rb#65
  def tracked_visibility=(_arg0); end
end

# source://reek//lib/reek/context/visibility_tracker.rb#8
Reek::Context::VisibilityTracker::VISIBILITY_MAP = T.let(T.unsafe(nil), Hash)

# source://reek//lib/reek/context/visibility_tracker.rb#7
Reek::Context::VisibilityTracker::VISIBILITY_MODIFIERS = T.let(T.unsafe(nil), Array)

# Traverses an abstract syntax tree and fires events whenever it encounters
# specific node types.
#
# TODO: This class is responsible for statements and reference
# counting. Ideally `ContextBuilder` would only build up the context tree and leave the
# statement and reference counting to the contexts.
class Reek::ContextBuilder
  # @return [ContextBuilder] a new instance of ContextBuilder
  #
  # source://reek//lib/reek/context_builder.rb#30
  def initialize(syntax_tree); end

  # Returns the value of attribute context_tree.
  #
  # source://reek//lib/reek/context_builder.rb#28
  def context_tree; end

  private

  # Appends a new child context to the current context but does not change
  # the current context.
  #
  # @param klass [Context::*Context] context class
  # @param args arguments for the class initializer
  # @return [Context::*Context] the context that was appended
  #
  # source://reek//lib/reek/context_builder.rb#513
  def append_new_context(klass, *args); end

  # Processes the given AST, memoizes it and returns a tree of nested
  # contexts.
  #
  # For example this ruby code:
  #
  #   class Car; def drive; end; end
  #
  # would get compiled into this AST:
  #
  #   (class
  #     (const nil :Car) nil
  #     (def :drive
  #       (args) nil))
  #
  # Processing this AST would result in a context tree where each node
  # contains the outer context, the AST and the child contexts. The top
  # node is always Reek::Context::RootContext. Using the example above,
  # the tree would look like this:
  #
  # RootContext -> children: 1 ModuleContext -> children: 1 MethodContext
  #
  # @return [Reek::Context::RootContext] tree of nested contexts
  #
  # source://reek//lib/reek/context_builder.rb#63
  def build(exp, parent_exp = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/context_builder.rb#477
  def context_processor_exists?(name); end

  # Returns the value of attribute current_context.
  #
  # source://reek//lib/reek/context_builder.rb#38
  def current_context; end

  # Sets the attribute current_context
  #
  # @param value the value to set the attribute current_context to.
  #
  # source://reek//lib/reek/context_builder.rb#38
  def current_context=(_arg0); end

  # source://reek//lib/reek/context_builder.rb#486
  def decrease_statement_count; end

  # Returns the value of attribute exp.
  #
  # source://reek//lib/reek/context_builder.rb#39
  def exp; end

  # source://reek//lib/reek/context_builder.rb#519
  def handle_refinement_block(exp); end

  # source://reek//lib/reek/context_builder.rb#531
  def handle_send_for_methods(exp); end

  # source://reek//lib/reek/context_builder.rb#525
  def handle_send_for_modules(exp); end

  # source://reek//lib/reek/context_builder.rb#482
  def increase_statement_count_by(sexp); end

  # Stores a reference to the current context, creates a nested new one,
  # yields to the given block and then restores the previous context.
  #
  # @param klass [Context::*Context] context class
  # @param args arguments for the class initializer
  # @yield block
  #
  # source://reek//lib/reek/context_builder.rb#497
  def inside_new_context(klass, *args); end

  # Handles every node for which we have no context_processor.
  #
  # source://reek//lib/reek/context_builder.rb#75
  def process(exp); end

  # Handles `begin` and `kwbegin` nodes. `begin` nodes are created implicitly
  # e.g. when parsing method bodies (see example below), `kwbegin` nodes are created
  # by explicitly using the `begin` keyword.
  #
  # An input example that would trigger this method would be:
  #
  #   def foo; call_me(); @x = 5; end
  #
  # In this case the whole method body would be hanging below the `begin` node.
  #
  # Counts all statements in the method body.
  #
  # At the end we subtract one statement because the surrounding context was already counted
  # as one (e.g. via `process_def`).
  #
  # source://reek//lib/reek/context_builder.rb#294
  def process_begin(exp, _parent); end

  # Handles `block` nodes.
  #
  # An input example that would trigger this method would be:
  #
  #   list.map { |element| puts element }
  #
  # Counts non-empty blocks as one statement.
  #
  # A refinement block is handled differently and causes a RefinementContext
  # to be opened.
  #
  # source://reek//lib/reek/context_builder.rb#270
  def process_block(exp, _parent); end

  # Handles `case` nodes.
  #
  # An input example that would trigger this method would be:
  #
  # foo = 5
  # case foo
  # when 1..100
  #   puts 'In between'
  # else
  #   puts 'Not sure what I got here'
  # end
  #
  # Counts the `else` body.
  #
  # At the end we subtract one statement because the surrounding context was already counted
  # as one (e.g. via `process_def`).
  #
  # source://reek//lib/reek/context_builder.rb#446
  def process_case(exp, _parent); end

  # Handles `casgn` ("class assign") nodes.
  #
  # An input example that would trigger this method would be:
  #
  #   Foo = Class.new Bar
  #
  # source://reek//lib/reek/context_builder.rb#108
  def process_casgn(exp, parent); end

  # Handles `module` and `class` nodes.
  #
  # source://reek//lib/reek/context_builder.rb#81
  def process_class(exp, _parent); end

  # Handles `def` nodes.
  #
  # An input example that would trigger this method would be:
  #
  #   def call_me; foo = 2; bar = 5; end
  #
  # Given the above example we would count 2 statements overall.
  #
  # source://reek//lib/reek/context_builder.rb#124
  def process_def(exp, parent); end

  # Handles `defs` nodes ("define singleton").
  #
  # An input example that would trigger this method would be:
  #
  #   def self.call_me; foo = 2; bar = 5; end
  #
  # Given the above example we would count 2 statements overall.
  #
  # source://reek//lib/reek/context_builder.rb#139
  def process_defs(exp, parent); end

  # Handles `for` nodes.
  #
  # An input example that would trigger this method would be:
  #
  # for i in [1,2,3,4]
  #   puts i
  # end
  #
  # Counts the `for` body as one statement.
  #
  # At the end we subtract one statement because the surrounding context was already counted
  # as one (e.g. via `process_def`).
  #
  # `children[2]` below refers to the `while` body (so `puts i` from above)
  #
  # source://reek//lib/reek/context_builder.rb#366
  def process_for(exp, _parent); end

  # Handles `if` nodes.
  #
  # An input example that would trigger this method would be:
  #
  # if a > 5 && b < 3
  #   puts 'bingo'
  # else
  #   3
  # end
  #
  # Counts the `if` body as one statement and the `else` body as another statement.
  #
  # At the end we subtract one statement because the surrounding context was already counted
  # as one (e.g. via `process_def`).
  #
  # `children[1]` refers to the `if` body (so `puts 'bingo'` from above) and
  # `children[2]` to the `else` body (so `3` from above), which might be nil.
  #
  # source://reek//lib/reek/context_builder.rb#320
  def process_if(exp, _parent); end

  # Handles `ivasgn` and `ivar` nodes a.k.a. nodes related to instance variables.
  #
  # An input example that would trigger this method would be:
  #
  #   @item = 5
  #
  # for instance assignments (`ivasgn`) and
  #
  #   call_me(@item)
  #
  # for just using instance variables (`ivar`).
  #
  # We record one reference to `self`.
  #
  # source://reek//lib/reek/context_builder.rb#197
  def process_ivar(exp, _parent); end

  # Handles `ivasgn` and `ivar` nodes a.k.a. nodes related to instance variables.
  #
  # An input example that would trigger this method would be:
  #
  #   @item = 5
  #
  # for instance assignments (`ivasgn`) and
  #
  #   call_me(@item)
  #
  # for just using instance variables (`ivar`).
  #
  # We record one reference to `self`.
  #
  # source://reek//lib/reek/context_builder.rb#197
  def process_ivasgn(exp, _parent); end

  # Handles `begin` and `kwbegin` nodes. `begin` nodes are created implicitly
  # e.g. when parsing method bodies (see example below), `kwbegin` nodes are created
  # by explicitly using the `begin` keyword.
  #
  # An input example that would trigger this method would be:
  #
  #   def foo; call_me(); @x = 5; end
  #
  # In this case the whole method body would be hanging below the `begin` node.
  #
  # Counts all statements in the method body.
  #
  # At the end we subtract one statement because the surrounding context was already counted
  # as one (e.g. via `process_def`).
  #
  # source://reek//lib/reek/context_builder.rb#294
  def process_kwbegin(exp, _parent); end

  # Handles `module` and `class` nodes.
  #
  # source://reek//lib/reek/context_builder.rb#81
  def process_module(exp, _parent); end

  # Handles `op_asgn` nodes a.k.a. Ruby's assignment operators.
  #
  # An input example that would trigger this method would be:
  #
  #   x += 5
  #
  # or
  #
  #   x *= 3
  #
  # We record one reference to `x` given the example above.
  #
  # source://reek//lib/reek/context_builder.rb#178
  def process_op_asgn(exp, _parent); end

  # Handles `resbody` nodes.
  #
  # An input example that would trigger this method would be:
  #
  # def simple
  #   raise ArgumentError, 'raising...'
  # rescue => e
  #   puts 'rescued!'
  # end
  #
  # Counts the exception capturing and every statement related to it.
  #
  # So `exp.children[1..-1]` from the code below would be an array with the following 2 elements:
  # [
  #   (lvasgn :e),
  #   (send nil :puts (str "rescued!"))
  # ]
  #
  # which thus counts as 2 statements.
  # `exp` would be the whole `rescue` body.
  # See `process_rescue` for additional reference.
  #
  # source://reek//lib/reek/context_builder.rb#424
  def process_resbody(exp, _parent); end

  # Handles `rescue` nodes.
  #
  # An input example that would trigger this method would be:
  #
  # def simple
  #   raise ArgumentError, 'raising...'
  # rescue => e
  #   puts 'rescued!'
  # end
  #
  # Counts everything before the `rescue` body as one statement.
  #
  # At the end we subtract one statement because the surrounding context was already counted
  # as one (e.g. via `process_def`).
  #
  # `exp.children.first` below refers to everything before the actual `rescue`
  # which would be the
  #
  # raise ArgumentError, 'raising...'
  #
  # in the example above.
  # `exp` would be the whole method body wrapped under a `rescue` node.
  # See `process_resbody` for additional reference.
  #
  # source://reek//lib/reek/context_builder.rb#396
  def process_rescue(exp, _parent); end

  # Handles `sclass` nodes
  #
  # An input example that would trigger this method would be:
  #
  #   class << self
  #   end
  #
  # source://reek//lib/reek/context_builder.rb#96
  def process_sclass(exp, _parent); end

  # Handles `self` nodes.
  #
  # An input example that would trigger this method would be:
  #
  #   def self.foo; end
  #
  # source://reek//lib/reek/context_builder.rb#210
  def process_self(_exp, _parent); end

  # Handles `send` nodes a.k.a. method calls.
  #
  # An input example that would trigger this method would be:
  #
  #   call_me()
  #
  # Besides checking if it's a visibility modifier or an attribute writer
  # we also record to what the method call is referring to
  # which we later use for smell detectors like FeatureEnvy.
  #
  # source://reek//lib/reek/context_builder.rb#156
  def process_send(exp, _parent); end

  # Handles `super` nodes a.k.a. calls to `super` with arguments
  #
  # An input example that would trigger this method would be:
  #
  #   def call_me; super(); end
  #
  # or
  #
  #   def call_me; super(bar); end
  #
  # but not
  #
  #   def call_me; super; end
  #
  # and not
  #
  #   def call_me; super do end; end
  #
  # We record one reference to `self`.
  #
  # source://reek//lib/reek/context_builder.rb#254
  def process_super(exp, _parent); end

  # Handles `while` and `until` nodes.
  #
  # An input example that would trigger this method would be:
  #
  # while x < 5
  #   puts 'bingo'
  # end
  #
  # Counts the `while` body as one statement.
  #
  # At the end we subtract one statement because the surrounding context was already counted
  # as one (e.g. via `process_def`).
  #
  # `children[1]` below refers to the `while` body (so `puts 'bingo'` from above)
  #
  # source://reek//lib/reek/context_builder.rb#343
  def process_until(exp, _parent); end

  # Handles `when` nodes.
  #
  # An input example that would trigger this method would be:
  #
  # foo = 5
  # case foo
  # when (1..100)
  #   puts 'In between'
  # else
  #   puts 'Not sure what I got here'
  # end
  #
  # Note that input like
  #
  # if foo then :holla else :nope end
  #
  # does not trigger this method.
  #
  # Counts the `when` body.
  #
  # source://reek//lib/reek/context_builder.rb#472
  def process_when(exp, _parent); end

  # Handles `while` and `until` nodes.
  #
  # An input example that would trigger this method would be:
  #
  # while x < 5
  #   puts 'bingo'
  # end
  #
  # Counts the `while` body as one statement.
  #
  # At the end we subtract one statement because the surrounding context was already counted
  # as one (e.g. via `process_def`).
  #
  # `children[1]` below refers to the `while` body (so `puts 'bingo'` from above)
  #
  # source://reek//lib/reek/context_builder.rb#343
  def process_while(exp, _parent); end

  # Handles `zsuper` nodes a.k.a. calls to `super` without any arguments but a block possibly.
  #
  # An input example that would trigger this method would be:
  #
  #   def call_me; super; end
  #
  # or
  #
  #   def call_me; super do end; end
  #
  # but not
  #
  #   def call_me; super(); end
  #
  # We record one reference to `self`.
  #
  # source://reek//lib/reek/context_builder.rb#230
  def process_zsuper(_exp, _parent); end

  # source://reek//lib/reek/context_builder.rb#536
  def register_attributes(exp); end
end

# source://reek//lib/reek.rb#12
Reek::DEFAULT_CONFIGURATION_FILE_NAME = T.let(T.unsafe(nil), String)

# source://reek//lib/reek.rb#11
Reek::DEFAULT_SMELL_CONFIGURATION = T.let(T.unsafe(nil), String)

# source://reek//lib/reek.rb#13
Reek::DETECTORS_KEY = T.let(T.unsafe(nil), String)

# source://reek//lib/reek.rb#15
Reek::DIRECTORIES_KEY = T.let(T.unsafe(nil), String)

# Contains all the existing smell detectors and exposes operations on them.
class Reek::DetectorRepository
  # @return [DetectorRepository] a new instance of DetectorRepository
  #
  # source://reek//lib/reek/detector_repository.rb#35
  def initialize(smell_types: T.unsafe(nil), configuration: T.unsafe(nil)); end

  # source://reek//lib/reek/detector_repository.rb#41
  def examine(context); end

  private

  # Returns the value of attribute configuration.
  #
  # source://reek//lib/reek/detector_repository.rb#56
  def configuration; end

  # source://reek//lib/reek/detector_repository.rb#58
  def configuration_for(klass); end

  # source://reek//lib/reek/detector_repository.rb#62
  def smell_detectors_for(type); end

  # Returns the value of attribute smell_types.
  #
  # source://reek//lib/reek/detector_repository.rb#56
  def smell_types; end

  class << self
    # @return [Array<String>] The names of all known SmellDetectors
    #   e.g. ["BooleanParameter", "ClassVariable"].
    #
    # source://reek//lib/reek/detector_repository.rb#50
    def available_detector_names; end

    # @param filter_by_smells [Array<String>] List of smell types to filter by, e.g. "DuplicateMethodCall".
    #   More precisely it should be whatever is returned by `BaseDetector`.smell_type.
    #   This means that you can write the "DuplicateMethodCall" from above also like this:
    #   Reek::SmellDetectors::DuplicateMethodCall.smell_type
    #   if you want to make sure you do not fat-finger strings.
    # @return [Array<Reek::SmellDetectors::BaseDetector>] All SmellDetectors that we want to filter for
    #   e.g. [Reek::SmellDetectors::Attribute].
    #
    # source://reek//lib/reek/detector_repository.rb#27
    def eligible_smell_types(filter_by_smells = T.unsafe(nil)); end

    # @return [Array<Reek::SmellDetectors::BaseDetector>] All known SmellDetectors
    #   e.g. [Reek::SmellDetectors::BooleanParameter, Reek::SmellDetectors::ClassVariable].
    #
    # source://reek//lib/reek/detector_repository.rb#14
    def smell_types; end
  end
end

# Generate versioned links to our documentation
module Reek::DocumentationLink
  private

  # Build link to the documentation about the given subject for the current
  # version of Reek. The subject can be either a smell type like
  # 'FeatureEnvy' or a general subject like 'Rake Task'.
  #
  # @param subject [String]
  # @return [String] the full URL for the relevant documentation
  #
  # source://reek//lib/reek/documentation_link.rb#16
  def build(subject); end

  # Convert the given subject name to a form that is acceptable in a URL.
  #
  # source://reek//lib/reek/documentation_link.rb#21
  def name_to_param(name); end

  class << self
    # Build link to the documentation about the given subject for the current
    # version of Reek. The subject can be either a smell type like
    # 'FeatureEnvy' or a general subject like 'Rake Task'.
    #
    # @param subject [String]
    # @return [String] the full URL for the relevant documentation
    #
    # source://reek//lib/reek/documentation_link.rb#16
    def build(subject); end

    # Convert the given subject name to a form that is acceptable in a URL.
    #
    # source://reek//lib/reek/documentation_link.rb#21
    def name_to_param(name); end
  end
end

# source://reek//lib/reek/documentation_link.rb#6
Reek::DocumentationLink::HELP_LINK_TEMPLATE = T.let(T.unsafe(nil), String)

# source://reek//lib/reek.rb#14
Reek::EXCLUDE_PATHS_KEY = T.let(T.unsafe(nil), String)

module Reek::Errors; end

# Gets raised when trying to configure a detector with an option
# which is unknown to it.
class Reek::Errors::BadDetectorConfigurationKeyInCommentError < ::Reek::Errors::BaseError
  # @return [BadDetectorConfigurationKeyInCommentError] a new instance of BadDetectorConfigurationKeyInCommentError
  #
  # source://reek//lib/reek/errors/bad_detector_configuration_key_in_comment_error.rb#28
  def initialize(detector_name:, offensive_keys:, source:, line:, original_comment:); end
end

# source://reek//lib/reek/errors/bad_detector_configuration_key_in_comment_error.rb#11
Reek::Errors::BadDetectorConfigurationKeyInCommentError::UNKNOWN_SMELL_DETECTOR_MESSAGE = T.let(T.unsafe(nil), String)

# Gets raised when trying to configure a detector which is unknown to us.
# This might happen for multiple reasons. The users might have a typo in
# his comment or he might use a detector that does not exist anymore.
class Reek::Errors::BadDetectorInCommentError < ::Reek::Errors::BaseError
  # @return [BadDetectorInCommentError] a new instance of BadDetectorInCommentError
  #
  # source://reek//lib/reek/errors/bad_detector_in_comment_error.rb#28
  def initialize(detector_name:, source:, line:, original_comment:); end
end

# source://reek//lib/reek/errors/bad_detector_in_comment_error.rb#12
Reek::Errors::BadDetectorInCommentError::UNKNOWN_SMELL_DETECTOR_MESSAGE = T.let(T.unsafe(nil), String)

# Base class for all runtime Reek errors
class Reek::Errors::BaseError < ::RuntimeError
  # source://reek//lib/reek/errors/base_error.rb#7
  def long_message; end
end

# Gets raised when Reek is unable to process the source due to bad config file
class Reek::Errors::ConfigFileError < ::Reek::Errors::BaseError; end

# Gets raised when Reek is unable to process the source due to an EncodingError
class Reek::Errors::EncodingError < ::Reek::Errors::BaseError
  # @return [EncodingError] a new instance of EncodingError
  #
  # source://reek//lib/reek/errors/encoding_error.rb#31
  def initialize(origin:); end

  # source://reek//lib/reek/errors/encoding_error.rb#35
  def long_message; end
end

# source://reek//lib/reek/errors/encoding_error.rb#11
Reek::Errors::EncodingError::LONG_TEMPLATE = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/errors/encoding_error.rb#9
Reek::Errors::EncodingError::TEMPLATE = T.let(T.unsafe(nil), String)

# Gets raised when trying to use a configuration for a detector
# that can't be parsed into a hash.
class Reek::Errors::GarbageDetectorConfigurationInCommentError < ::Reek::Errors::BaseError
  # @return [GarbageDetectorConfigurationInCommentError] a new instance of GarbageDetectorConfigurationInCommentError
  #
  # source://reek//lib/reek/errors/garbage_detector_configuration_in_comment_error.rb#27
  def initialize(detector_name:, source:, line:, original_comment:); end
end

# source://reek//lib/reek/errors/garbage_detector_configuration_in_comment_error.rb#11
Reek::Errors::GarbageDetectorConfigurationInCommentError::BAD_DETECTOR_CONFIGURATION_MESSAGE = T.let(T.unsafe(nil), String)

# Gets raised when Reek is unable to process the source
class Reek::Errors::IncomprehensibleSourceError < ::Reek::Errors::BaseError
  # @return [IncomprehensibleSourceError] a new instance of IncomprehensibleSourceError
  #
  # source://reek//lib/reek/errors/incomprehensible_source_error.rb#34
  def initialize(origin:); end

  # source://reek//lib/reek/errors/incomprehensible_source_error.rb#38
  def long_message; end
end

# source://reek//lib/reek/errors/incomprehensible_source_error.rb#11
Reek::Errors::IncomprehensibleSourceError::LONG_TEMPLATE = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/errors/incomprehensible_source_error.rb#9
Reek::Errors::IncomprehensibleSourceError::TEMPLATE = T.let(T.unsafe(nil), String)

# Gets raised for old-style comment configuration format.
class Reek::Errors::LegacyCommentSeparatorError < ::Reek::Errors::BaseError
  # @return [LegacyCommentSeparatorError] a new instance of LegacyCommentSeparatorError
  #
  # source://reek//lib/reek/errors/legacy_comment_separator_error.rb#27
  def initialize(source:, line:, original_comment:); end
end

# source://reek//lib/reek/errors/legacy_comment_separator_error.rb#9
Reek::Errors::LegacyCommentSeparatorError::MESSAGE = T.let(T.unsafe(nil), String)

# Gets raised when Reek is unable to process the source due to a SyntaxError
class Reek::Errors::SyntaxError < ::Reek::Errors::BaseError
  # @return [SyntaxError] a new instance of SyntaxError
  #
  # source://reek//lib/reek/errors/syntax_error.rb#33
  def initialize(origin:); end

  # source://reek//lib/reek/errors/syntax_error.rb#37
  def long_message; end
end

# source://reek//lib/reek/errors/syntax_error.rb#11
Reek::Errors::SyntaxError::LONG_TEMPLATE = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/errors/syntax_error.rb#9
Reek::Errors::SyntaxError::TEMPLATE = T.let(T.unsafe(nil), String)

# Applies all available smell detectors to a source.
class Reek::Examiner
  # Creates an Examiner which scans the given +source+ for code smells.
  #
  # @param source [File, IO, String] If +source+ is a String it is assumed to be Ruby source code;
  #   if it is a File or IO, it is opened and Ruby source code is read from it;
  # @param filter_by_smells [Array<String>] List of smell types to filter by, e.g. "DuplicateMethodCall".
  # @param configuration [Configuration::AppConfiguration] The configuration for this Examiner.
  # @return [Examiner] a new instance of Examiner
  #
  # source://reek//lib/reek/examiner.rb#38
  def initialize(source, filter_by_smells: T.unsafe(nil), configuration: T.unsafe(nil), detector_repository_class: T.unsafe(nil), error_handler: T.unsafe(nil)); end

  # @return [String] origin of the source being analysed
  #
  # source://reek//lib/reek/examiner.rb#54
  def origin; end

  # @return [Array<SmellWarning>] the smells found in the source
  #
  # source://reek//lib/reek/examiner.rb#60
  def smells; end

  # @return [Integer] the number of smells found in the source
  #
  # source://reek//lib/reek/examiner.rb#68
  def smells_count; end

  # @return [Boolean] true if and only if there are code smells in the source.
  #
  # source://reek//lib/reek/examiner.rb#76
  def smelly?; end

  private

  # Returns the value of attribute detector_repository.
  #
  # source://reek//lib/reek/examiner.rb#82
  def detector_repository; end

  # source://reek//lib/reek/examiner.rb#119
  def examine_tree; end

  # Runs the Examiner on the given source to scan for code smells.
  #
  # In case one of the smell detectors raises an exception we probably hit a Reek bug.
  # So we catch the exception here, let the user know something went wrong
  # and continue with the analysis.
  #
  # @return [Array<SmellWarning>] the smells found in the source
  #
  # source://reek//lib/reek/examiner.rb#92
  def run; end

  # Returns the value of attribute source.
  #
  # source://reek//lib/reek/examiner.rb#82
  def source; end

  # source://reek//lib/reek/examiner.rb#115
  def syntax_tree; end

  # source://reek//lib/reek/examiner.rb#103
  def wrap_exceptions; end
end

# Handles no errors
class Reek::Examiner::NullHandler
  # source://reek//lib/reek/examiner.rb#19
  def handle(_exception); end
end

# A set of context-specific overrides for smell detectors.
class Reek::Overrides
  # @return [Overrides] a new instance of Overrides
  #
  # source://reek//lib/reek/smell_configuration.rb#51
  def initialize(hash); end

  # Find any overrides that match the supplied context
  #
  # source://reek//lib/reek/smell_configuration.rb#56
  def for_context(context); end

  private

  # Returns the value of attribute hash.
  #
  # source://reek//lib/reek/smell_configuration.rb#63
  def hash; end
end

# Reek reporting functionality.
module Reek::Report
  class << self
    # Map heading format symbol to a report class.
    #
    # @param heading_format [Symbol] The format to map
    # @return The mapped heading class
    #
    # source://reek//lib/reek/report.rb#73
    def heading_formatter(heading_format); end

    # Map location format symbol to a report class.
    #
    # @param location_format [Symbol] The format to map
    # @return The mapped location class
    #
    # source://reek//lib/reek/report.rb#63
    def location_formatter(location_format); end

    # Map progress format symbol to a report class.
    #
    # @param progress_format [Symbol] The format to map
    # @return The mapped progress class
    #
    # source://reek//lib/reek/report.rb#83
    def progress_formatter(progress_format); end

    # Map report format symbol to a report class.
    #
    # @param report_format [Symbol] The format to map
    # @return The mapped report class
    #
    # source://reek//lib/reek/report.rb#53
    def report_class(report_format); end

    # Map warning format symbol to a report class.
    #
    # @param warning_format [Symbol] The format to map
    # @return The mapped warning class
    #
    # source://reek//lib/reek/report.rb#93
    def warning_formatter_class(warning_format); end
  end
end

# A report that contains the smells and smell counts following source code analysis.
#
# @abstract Subclass and override {#show} to create a concrete report class.
class Reek::Report::BaseReport
  # @return [BaseReport] a new instance of BaseReport
  #
  # source://reek//lib/reek/report/base_report.rb#25
  def initialize(heading_formatter: T.unsafe(nil), sort_by_issue_count: T.unsafe(nil), warning_formatter: T.unsafe(nil), progress_formatter: T.unsafe(nil)); end

  # Add Examiner to report on. The report will output results for all
  # added examiners.
  #
  # @param examiner [Reek::Examiner] object to report on
  #
  # source://reek//lib/reek/report/base_report.rb#43
  def add_examiner(examiner); end

  # Render the report results on STDOUT
  #
  # @raise [NotImplementedError]
  #
  # source://reek//lib/reek/report/base_report.rb#52
  def show; end

  # source://reek//lib/reek/report/base_report.rb#60
  def smells; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/report/base_report.rb#56
  def smells?; end

  protected

  # Returns the value of attribute total_smell_count.
  #
  # source://reek//lib/reek/report/base_report.rb#66
  def total_smell_count; end

  # Sets the attribute total_smell_count
  #
  # @param value the value to set the attribute total_smell_count to.
  #
  # source://reek//lib/reek/report/base_report.rb#66
  def total_smell_count=(_arg0); end

  private

  # Returns the value of attribute examiners.
  #
  # source://reek//lib/reek/report/base_report.rb#70
  def examiners; end

  # Returns the value of attribute heading_formatter.
  #
  # source://reek//lib/reek/report/base_report.rb#70
  def heading_formatter; end

  # Returns the value of attribute progress_formatter.
  #
  # source://reek//lib/reek/report/base_report.rb#70
  def progress_formatter; end

  # Returns the value of attribute sort_by_issue_count.
  #
  # source://reek//lib/reek/report/base_report.rb#70
  def sort_by_issue_count; end

  # Returns the value of attribute warning_formatter.
  #
  # source://reek//lib/reek/report/base_report.rb#70
  def warning_formatter; end
end

# source://reek//lib/reek/report/base_report.rb#19
Reek::Report::BaseReport::NO_WARNINGS_COLOR = T.let(T.unsafe(nil), Symbol)

# source://reek//lib/reek/report/base_report.rb#20
Reek::Report::BaseReport::WARNINGS_COLOR = T.let(T.unsafe(nil), Symbol)

# Formats the location of a warning as an empty string.
module Reek::Report::BlankLocationFormatter
  private

  # source://reek//lib/reek/report/location_formatter.rb#11
  def format(_warning); end

  class << self
    # source://reek//lib/reek/report/location_formatter.rb#11
    def format(_warning); end
  end
end

# Formats the location of a warning as an array of line numbers.
module Reek::Report::DefaultLocationFormatter
  private

  # source://reek//lib/reek/report/location_formatter.rb#22
  def format(warning); end

  class << self
    # source://reek//lib/reek/report/location_formatter.rb#22
    def format(warning); end
  end
end

# Formatter that adds a link to the docs to the basic message from
# SimpleWarningFormatter.
class Reek::Report::DocumentationLinkWarningFormatter < ::Reek::Report::SimpleWarningFormatter
  # source://reek//lib/reek/report/documentation_link_warning_formatter.rb#12
  def format(warning); end
end

# source://reek//lib/reek/report.rb#32
Reek::Report::HEADING_FORMATTERS = T.let(T.unsafe(nil), Hash)

# Saves the report as a HTML file
class Reek::Report::HTMLReport < ::Reek::Report::BaseReport
  # source://reek//lib/reek/report/html_report.rb#16
  def show; end
end

# Base class for heading formatters.
# Is responsible for formatting the heading emitted for each examiner
#
# @abstract Override {#show_header?} to implement a heading formatter.
class Reek::Report::HeadingFormatterBase
  # source://reek//lib/reek/report/heading_formatter.rb#16
  def header(examiner); end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://reek//lib/reek/report/heading_formatter.rb#12
  def show_header?(_examiner); end

  private

  # source://reek//lib/reek/report/heading_formatter.rb#26
  def formatted_header(examiner); end
end

# Displays a list of smells in JSON format
# JSON with empty array for 0 smells
class Reek::Report::JSONReport < ::Reek::Report::BaseReport
  # source://reek//lib/reek/report/json_report.rb#14
  def show(out = T.unsafe(nil)); end
end

# source://reek//lib/reek/report.rb#26
Reek::Report::LOCATION_FORMATTERS = T.let(T.unsafe(nil), Hash)

# source://reek//lib/reek/report.rb#37
Reek::Report::PROGRESS_FORMATTERS = T.let(T.unsafe(nil), Hash)

module Reek::Report::ProgressFormatter; end

# Base class for progress formatters.
# Is responsible for formatting the progress emitted for each examiner
#
# @abstract Override {#header, #progress, #footer} to implement a progress formatter.
class Reek::Report::ProgressFormatter::Base
  # @return [Base] a new instance of Base
  #
  # source://reek//lib/reek/report/progress_formatter.rb#14
  def initialize(sources_count); end

  # @raise [NotImplementedError]
  #
  # source://reek//lib/reek/report/progress_formatter.rb#26
  def footer; end

  # @raise [NotImplementedError]
  #
  # source://reek//lib/reek/report/progress_formatter.rb#18
  def header; end

  # @raise [NotImplementedError]
  #
  # source://reek//lib/reek/report/progress_formatter.rb#22
  def progress(_examiner); end

  # Returns the value of attribute sources_count.
  #
  # source://reek//lib/reek/report/progress_formatter.rb#12
  def sources_count; end
end

# Shows the status of each source as either a dot (.) or an S
class Reek::Report::ProgressFormatter::Dots < ::Reek::Report::ProgressFormatter::Base
  # source://reek//lib/reek/report/progress_formatter.rb#46
  def footer; end

  # source://reek//lib/reek/report/progress_formatter.rb#38
  def header; end

  # source://reek//lib/reek/report/progress_formatter.rb#42
  def progress(examiner); end

  private

  # source://reek//lib/reek/report/progress_formatter.rb#52
  def display_clean; end

  # source://reek//lib/reek/report/progress_formatter.rb#56
  def display_smelly; end
end

# source://reek//lib/reek/report/progress_formatter.rb#35
Reek::Report::ProgressFormatter::Dots::NO_WARNINGS_COLOR = T.let(T.unsafe(nil), Symbol)

# source://reek//lib/reek/report/progress_formatter.rb#36
Reek::Report::ProgressFormatter::Dots::WARNINGS_COLOR = T.let(T.unsafe(nil), Symbol)

# Does not show progress
class Reek::Report::ProgressFormatter::Quiet < ::Reek::Report::ProgressFormatter::Base
  # source://reek//lib/reek/report/progress_formatter.rb#73
  def footer; end

  # source://reek//lib/reek/report/progress_formatter.rb#65
  def header; end

  # source://reek//lib/reek/report/progress_formatter.rb#69
  def progress(_examiner); end
end

# Lists only smelly examiners
class Reek::Report::QuietHeadingFormatter < ::Reek::Report::HeadingFormatterBase
  # @return [Boolean]
  #
  # source://reek//lib/reek/report/heading_formatter.rb#49
  def show_header?(examiner); end
end

# source://reek//lib/reek/report.rb#18
Reek::Report::REPORT_CLASSES = T.let(T.unsafe(nil), Hash)

# Basic formatter that just shows a simple message for each warning,
# prepended with the result of the passed-in location formatter.
class Reek::Report::SimpleWarningFormatter
  # @return [SimpleWarningFormatter] a new instance of SimpleWarningFormatter
  #
  # source://reek//lib/reek/report/simple_warning_formatter.rb#10
  def initialize(location_formatter: T.unsafe(nil)); end

  # source://reek//lib/reek/report/simple_warning_formatter.rb#14
  def format(warning); end

  # source://reek//lib/reek/report/simple_warning_formatter.rb#18
  def format_list(warnings); end

  private

  # Returns the value of attribute location_formatter.
  #
  # source://reek//lib/reek/report/simple_warning_formatter.rb#24
  def location_formatter; end
end

# Formats the location of a warning as a combination of source file name
# and line number. In this format, it is not possible to show more than
# one line number, so the first number is displayed.
module Reek::Report::SingleLineLocationFormatter
  private

  # source://reek//lib/reek/report/location_formatter.rb#35
  def format(warning); end

  class << self
    # source://reek//lib/reek/report/location_formatter.rb#35
    def format(warning); end
  end
end

# Generates a sorted, text summary of smells in examiners
class Reek::Report::TextReport < ::Reek::Report::BaseReport
  # @return [TextReport] a new instance of TextReport
  #
  # source://reek//lib/reek/report/text_report.rb#14
  def initialize(**args); end

  # source://reek//lib/reek/report/text_report.rb#21
  def add_examiner(examiner); end

  # source://reek//lib/reek/report/text_report.rb#27
  def show; end

  private

  # source://reek//lib/reek/report/text_report.rb#40
  def display_summary; end

  # source://reek//lib/reek/report/text_report.rb#44
  def display_total_smell_count; end

  # source://reek//lib/reek/report/text_report.rb#36
  def smell_summaries; end

  # source://reek//lib/reek/report/text_report.rb#59
  def sort_examiners; end

  # source://reek//lib/reek/report/text_report.rb#50
  def summarize_single_examiner(examiner); end

  # source://reek//lib/reek/report/text_report.rb#63
  def total_smell_count_message; end
end

# Lists out each examiner, even if it has no smell
class Reek::Report::VerboseHeadingFormatter < ::Reek::Report::HeadingFormatterBase
  # @return [Boolean]
  #
  # source://reek//lib/reek/report/heading_formatter.rb#39
  def show_header?(_examiner); end
end

# source://reek//lib/reek/report.rb#42
Reek::Report::WARNING_FORMATTER_CLASSES = T.let(T.unsafe(nil), Hash)

# Generates a list of smells in XML format
class Reek::Report::XMLReport < ::Reek::Report::BaseReport
  # source://reek//lib/reek/report/xml_report.rb#16
  def show; end

  private

  # source://reek//lib/reek/report/xml_report.rb#29
  def checkstyle; end

  # source://reek//lib/reek/report/xml_report.rb#23
  def document; end

  # source://reek//lib/reek/report/xml_report.rb#51
  def error(smell, line); end

  # source://reek//lib/reek/report/xml_report.rb#39
  def file(name, smells); end
end

# Displays a list of smells in YAML format
# YAML with empty array for 0 smells
class Reek::Report::YAMLReport < ::Reek::Report::BaseReport
  # source://reek//lib/reek/report/yaml_report.rb#14
  def show(out = T.unsafe(nil)); end
end

# Represents a single set of configuration options for a smell detector
class Reek::SmellConfiguration
  # @return [SmellConfiguration] a new instance of SmellConfiguration
  #
  # source://reek//lib/reek/smell_configuration.rb#16
  def initialize(hash); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_configuration.rb#24
  def enabled?; end

  # source://reek//lib/reek/smell_configuration.rb#20
  def merge(new_options); end

  # source://reek//lib/reek/smell_configuration.rb#28
  def overrides_for(context); end

  # Retrieves the value, if any, for the given +key+ in the given +context+.
  #
  # Raises an error if neither the context nor this config have a value for
  # the key.
  #
  # source://reek//lib/reek/smell_configuration.rb#37
  def value(key, context); end

  private

  # Returns the value of attribute options.
  #
  # source://reek//lib/reek/smell_configuration.rb#44
  def options; end
end

# The name of the config field that specifies whether a smell is
# enabled. Set to +true+ or +false+.
#
# source://reek//lib/reek/smell_configuration.rb#10
Reek::SmellConfiguration::ENABLED_KEY = T.let(T.unsafe(nil), String)

# The name of the config field that sets scope-specific overrides
# for other values in the current smell detector's configuration.
#
# source://reek//lib/reek/smell_configuration.rb#14
Reek::SmellConfiguration::OVERRIDES_KEY = T.let(T.unsafe(nil), String)

module Reek::SmellDetectors; end

# A class that publishes a getter or setter for an instance variable
# invites client classes to become too intimate with its inner workings,
# and in particular with its representation of state.
#
# This detector raises a warning for every public +attr_writer+,
# +attr_accessor+, and +attr+ with the writable flag set to +true+.
#
# See {file:docs/Attribute.md} for details.
#
# TODO: Catch attributes declared "by hand"
class Reek::SmellDetectors::Attribute < ::Reek::SmellDetectors::BaseDetector
  # Checks whether the given class declares any attributes.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/attribute.rb#28
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/attribute.rb#38
  def attributes_in_context; end

  class << self
    # source://reek//lib/reek/smell_detectors/attribute.rb#19
    def contexts; end
  end
end

# Shared responsibilities of all smell detectors.
#
# See
#   - {file:docs/Basic-Smell-Options.md}
#   - {file:docs/Code-Smells.md}
#   - {file:README.md}
# for details.
class Reek::SmellDetectors::BaseDetector
  # @return [BaseDetector] a new instance of BaseDetector
  #
  # source://reek//lib/reek/smell_detectors/base_detector.rb#32
  def initialize(configuration: T.unsafe(nil), context: T.unsafe(nil)); end

  # Returns the value of attribute config.
  #
  # source://reek//lib/reek/smell_detectors/base_detector.rb#21
  def config; end

  # source://reek//lib/reek/smell_detectors/base_detector.rb#41
  def run; end

  # source://reek//lib/reek/smell_detectors/base_detector.rb#37
  def smell_type; end

  private

  # source://reek//lib/reek/smell_detectors/base_detector.rb#78
  def config_for(ctx); end

  # Returns the value of attribute context.
  #
  # source://reek//lib/reek/smell_detectors/base_detector.rb#56
  def context; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/base_detector.rb#70
  def enabled?; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/base_detector.rb#66
  def exception?; end

  # source://reek//lib/reek/smell_detectors/base_detector.rb#58
  def expression; end

  # source://reek//lib/reek/smell_detectors/base_detector.rb#82
  def smell_warning(**options); end

  # source://reek//lib/reek/smell_detectors/base_detector.rb#62
  def source_line; end

  # source://reek//lib/reek/smell_detectors/base_detector.rb#74
  def value(key, ctx); end

  class << self
    # @return [Set<Symbol>] all configuration keys that are available for this detector
    #
    # source://reek//lib/reek/smell_detectors/base_detector.rb#139
    def configuration_keys; end

    # source://reek//lib/reek/smell_detectors/base_detector.rb#96
    def contexts; end

    # source://reek//lib/reek/smell_detectors/base_detector.rb#101
    def default_config; end

    # Returns all descendants of BaseDetector
    #
    # @return [Array<Constant>] , e.g.:
    #   [Reek::SmellDetectors::Attribute,
    #   Reek::SmellDetectors::BooleanParameter,
    #   Reek::SmellDetectors::ClassVariable,
    #   ...]
    #
    # source://reek//lib/reek/smell_detectors/base_detector.rb#121
    def descendants; end

    # @private
    #
    # source://reek//lib/reek/smell_detectors/base_detector.rb#108
    def inherited(subclass); end

    # source://reek//lib/reek/smell_detectors/base_detector.rb#92
    def smell_type; end

    # Transform a detector name to the corresponding constant.
    # Note that we assume a valid name - exceptions are not handled here.
    #
    # @param detector_name [String] the detector in question, e.g. 'DuplicateMethodCall'
    # @return [SmellDetector] this will return the class, not an instance
    #
    # source://reek//lib/reek/smell_detectors/base_detector.rb#132
    def to_detector(detector_name); end

    # source://reek//lib/reek/smell_detectors/base_detector.rb#48
    def todo_configuration_for(smells); end
  end
end

# The default value for the +EXCLUDE_KEY+ if it isn't specified
# in any configuration file.
#
# source://reek//lib/reek/smell_detectors/base_detector.rb#30
Reek::SmellDetectors::BaseDetector::DEFAULT_EXCLUDE_SET = T.let(T.unsafe(nil), Array)

# The name of the config field that lists the names of code contexts
# that should not be checked. Add this field to the config for each
# smell that should ignore this code element.
#
# source://reek//lib/reek/smell_detectors/base_detector.rb#26
Reek::SmellDetectors::BaseDetector::EXCLUDE_KEY = T.let(T.unsafe(nil), String)

# A Boolean parameter effectively permits a method's caller
# to decide which execution path to take. The
# offending parameter is a kind of Control Couple.
#
# Currently Reek can only detect a Boolean parameter when it has a
# default initializer.
#
# See {file:docs/Boolean-Parameter.md} for details.
class Reek::SmellDetectors::BooleanParameter < ::Reek::SmellDetectors::BaseDetector
  # Checks whether the given method has any Boolean parameters.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/boolean_parameter.rb#24
  def sniff; end
end

# source://reek//lib/reek/smell_detectors/boolean_parameter.rb#17
Reek::SmellDetectors::BooleanParameter::BOOLEAN_VALUES = T.let(T.unsafe(nil), Array)

# Class variables form part of the global runtime state, and as such make
# it easy for one part of the system to accidentally or inadvertently
# depend on another part of the system. So the system becomes more prone to
# problems where changing something over here breaks something over there.
# In particular, class variables can make it hard to set up tests (because
# the context of the test includes all global state).
#
# See {file:docs/Class-Variable.md} for details.
class Reek::SmellDetectors::ClassVariable < ::Reek::SmellDetectors::BaseDetector
  # Collects the names of the class variables declared and/or used
  # in the given module.
  #
  # source://reek//lib/reek/smell_detectors/class_variable.rb#41
  def class_variables_in_context; end

  # Checks whether the given class or module declares any class variables.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/class_variable.rb#27
  def sniff; end

  class << self
    # source://reek//lib/reek/smell_detectors/class_variable.rb#18
    def contexts; end
  end
end

# Control Coupling occurs when a method or block checks the value of
# a parameter in order to decide which execution path to take. The
# offending parameter is often called a Control Couple.
#
# A simple example would be the <tt>quoted</tt> parameter
# in the following method:
#
#  def write(quoted)
#    if quoted
#      write_quoted(@value)
#    else
#      puts @value
#    end
#  end
#
# Control Coupling is a kind of duplication, because the calling method
# already knows which path should be taken.
#
# Control Coupling reduces the code's flexibility by creating a
# dependency between the caller and callee:
# any change to the possible values of the controlling parameter must
# be reflected on both sides of the call.
#
# A Control Couple also reveals a loss of simplicity: the called
# method probably has more than one responsibility,
# because it includes at least two different code paths.
#
# One possible solution is to use the Strategy Pattern
# to pass into the callee what must be done.  This is
# not considered to be control coupling because the
# callee will do the same thing with the strategy,
# whatever it happens to be.  Sometimes in Ruby the
# strategy may actually just be a block passed in, and
# that remains next to where the caller invokes it in
# the source code.
#
# See {file:docs/Control-Parameter.md} for details.
class Reek::SmellDetectors::ControlParameter < ::Reek::SmellDetectors::BaseDetector
  # Checks whether the given method chooses its execution path
  # by testing the value of one of its parameters.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/control_parameter.rb#54
  def sniff; end

  private

  # @return [Array<ControlParameterHelpers::Candidate>]
  #
  # source://reek//lib/reek/smell_detectors/control_parameter.rb#69
  def control_parameters; end

  # @param parameter [Symbol] the name of the parameter
  # @return [Array<Reek::AST::Node>]
  #
  # source://reek//lib/reek/smell_detectors/control_parameter.rb#86
  def find_matches(parameter); end

  # @return [Array<Symbol>] e.g. [:bravo, :charlie]
  #
  # source://reek//lib/reek/smell_detectors/control_parameter.rb#78
  def potential_parameters; end
end

module Reek::SmellDetectors::ControlParameterHelpers; end

# CallInConditionFinder finds usages of the given parameter
# in the context of a method call in a condition, e.g.:
#
# def alfa(bravo)
#   if charlie(bravo)
#     delta
#   end
# end
#
# or
#
# def alfa(bravo)
#   if bravo.charlie?
#     delta
#   end
# end
#
# Those usages are legit and should not trigger the ControlParameter smell warning.
class Reek::SmellDetectors::ControlParameterHelpers::CallInConditionFinder
  # @param node [Reek::AST::Node] the node in our current scope,
  #   e.g. s(:def, :alfa,
  #   s(:args,
  #   s(:arg, :bravo),
  # @param parameter [Symbol] the parameter name in question
  #   e.g. in the example above this would be :bravo
  # @return [CallInConditionFinder] a new instance of CallInConditionFinder
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/call_in_condition_finder.rb#37
  def initialize(node, parameter); end

  # @return [Boolean] if the parameter in question has been used in the context of a
  #   method call in a condition
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/call_in_condition_finder.rb#46
  def uses_param_in_call_in_condition?; end

  private

  # @return [Boolean] if the parameter is used in the given method call
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/call_in_condition_finder.rb#77
  def call_involving_param?(call_node); end

  # :reek:UtilityFunction
  #
  # @return [Boolean] if the given method call is a comparison call
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/call_in_condition_finder.rb#85
  def comparison_call?(call_node); end

  # Returns the value of attribute node.
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/call_in_condition_finder.rb#58
  def node; end

  # Returns the value of attribute parameter.
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/call_in_condition_finder.rb#58
  def parameter; end

  # @return [Boolean] if the parameter is used in a method call that is not a comparison call
  #   e.g. this would return true given that "bravo" is the parameter in question:
  #
  #   if charlie(bravo) then delta end
  #
  #   while this would return false (since its a comparison):
  #
  #   if bravo == charlie then charlie end
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/call_in_condition_finder.rb#70
  def regular_call_involving_param?(call_node); end
end

# source://reek//lib/reek/smell_detectors/control_parameter_helpers/call_in_condition_finder.rb#27
Reek::SmellDetectors::ControlParameterHelpers::CallInConditionFinder::COMPARISON_METHOD_NAMES = T.let(T.unsafe(nil), Array)

# Collects information about a single control parameter.
class Reek::SmellDetectors::ControlParameterHelpers::Candidate
  # @param parameter [Symbol] the parameter name
  # @param occurences [Array<Reek::AST::Node>] the occurences of the ControlParameter smell
  #   e.g. [s(:lvar, :bravo), s(:lvar, :bravo)]
  # @return [Candidate] a new instance of Candidate
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/candidate.rb#15
  def initialize(parameter, occurences); end

  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/candidate.rb#24
  def lines; end

  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/candidate.rb#28
  def name; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/candidate.rb#20
  def smells?; end

  private

  # Returns the value of attribute occurences.
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/candidate.rb#34
  def occurences; end

  # Returns the value of attribute parameter.
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/candidate.rb#34
  def parameter; end
end

# Finds cases of ControlParameter in a particular node for a particular parameter
class Reek::SmellDetectors::ControlParameterHelpers::ControlParameterFinder
  # @param node [Reek::AST::Node] the node in our current scope,
  #   e.g. s(:def, :alfa,
  #   s(:args,
  #   s(:arg, :bravo),
  # @param parameter [Symbol] the parameter name in question
  #   e.g. in the example above this would be :bravo
  # @return [ControlParameterFinder] a new instance of ControlParameterFinder
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#20
  def initialize(node, parameter); end

  # @return [Array<Reek::AST::Node>] all nodes where the parameter is used for control flow
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#28
  def find_matches; end

  # @return [Boolean] true if the parameter is not used for control flow
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#37
  def legitimate_uses?; end

  private

  # @return [Array<Reek::AST::Node>] the conditional nodes scoped below the current node
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#88
  def conditional_nodes; end

  # @return [Array<ControlParameterFinder>]
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#68
  def nested_finders; end

  # Returns the value of attribute node.
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#47
  def node; end

  # Returns the value of attribute parameter.
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#47
  def parameter; end

  # @return [Boolean] if the parameter is used in the body of the method
  #   e.g. this
  #
  #   def alfa(bravo)
  #   puts bravo
  #   if bravo then charlie end
  #   end
  #
  #   would cause this method to return true because of the "puts bravo"
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#60
  def parameter_used_in_body?; end

  # @return [Array<Reek::AST::Node>] all nodes where the parameter is part of a condition,
  #   e.g. [s(:lvar, :charlie)]
  #
  # source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#78
  def uses_of_param_in_condition; end
end

# source://reek//lib/reek/smell_detectors/control_parameter_helpers/control_parameter_finder.rb#11
Reek::SmellDetectors::ControlParameterHelpers::ControlParameterFinder::CONDITIONAL_NODE_TYPES = T.let(T.unsafe(nil), Array)

# A Data Clump occurs when the same two or three items frequently
# appear together in classes and parameter lists, or when a group
# of instance variable names start or end with similar substrings.
#
# The recurrence of the items often means there is duplicate code
# spread around to handle them. There may be an abstraction missing
# from the code, making the system harder to understand.
#
# Currently Reek looks for a group of two or more parameters with
# the same names that are expected by three or more methods of a class.
#
# See {file:docs/Data-Clump.md} for details.
class Reek::SmellDetectors::DataClump < ::Reek::SmellDetectors::BaseDetector
  # Checks the given class or module for multiple identical parameter sets.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/data_clump.rb#53
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/data_clump.rb#86
  def candidate_clumps; end

  # source://reek//lib/reek/smell_detectors/data_clump.rb#82
  def candidate_methods; end

  # source://reek//lib/reek/smell_detectors/data_clump.rb#103
  def clumps; end

  # source://reek//lib/reek/smell_detectors/data_clump.rb#95
  def common_argument_names_for(methods); end

  # source://reek//lib/reek/smell_detectors/data_clump.rb#74
  def max_copies; end

  # source://reek//lib/reek/smell_detectors/data_clump.rb#99
  def methods_containing_clump(clump); end

  # source://reek//lib/reek/smell_detectors/data_clump.rb#78
  def min_clump_size; end

  class << self
    # source://reek//lib/reek/smell_detectors/data_clump.rb#38
    def contexts; end

    # source://reek//lib/reek/smell_detectors/data_clump.rb#42
    def default_config; end

    # @private
    #
    # source://reek//lib/reek/smell_detectors/data_clump.rb#68
    def print_clump(clump); end
  end
end

# source://reek//lib/reek/smell_detectors/data_clump.rb#28
Reek::SmellDetectors::DataClump::DEFAULT_MAX_COPIES = T.let(T.unsafe(nil), Integer)

# source://reek//lib/reek/smell_detectors/data_clump.rb#36
Reek::SmellDetectors::DataClump::DEFAULT_MIN_CLUMP_SIZE = T.let(T.unsafe(nil), Integer)

# The name of the config field that sets the maximum allowed
# copies of any clump. No group of common parameters will be
# reported as a DataClump unless there are more than this many
# methods containing those parameters.
#
# source://reek//lib/reek/smell_detectors/data_clump.rb#27
Reek::SmellDetectors::DataClump::MAX_COPIES_KEY = T.let(T.unsafe(nil), String)

# The name of the config field that sets the minimum clump
# size. No group of common parameters will be reported as
# a DataClump unless it contains at least this many parameters.
#
# source://reek//lib/reek/smell_detectors/data_clump.rb#35
Reek::SmellDetectors::DataClump::MIN_CLUMP_SIZE_KEY = T.let(T.unsafe(nil), String)

# Duplication occurs when two fragments of code look nearly identical,
# or when two fragments of code have nearly identical effects
# at some conceptual level.
#
# +DuplicateMethodCall+ checks for repeated identical method calls
# within any one method definition. For example, the following method
# will report a warning:
#
#   def double_thing()
#     @other.thing + @other.thing
#   end
#
# See {file:docs/Duplicate-Method-Call.md} for details.
class Reek::SmellDetectors::DuplicateMethodCall < ::Reek::SmellDetectors::BaseDetector
  # Looks for duplicate calls within the body of the method context.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#44
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#62
  def allow_calls; end

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#58
  def max_allowed_calls; end

  class << self
    # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#33
    def default_config; end
  end
end

# The name of the config field that sets the names of any
# methods for which identical calls should be to be permitted
# within any single method.
#
# source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#30
Reek::SmellDetectors::DuplicateMethodCall::ALLOW_CALLS_KEY = T.let(T.unsafe(nil), String)

# Collects all calls in a given context
class Reek::SmellDetectors::DuplicateMethodCall::CallCollector
  # @return [CallCollector] a new instance of CallCollector
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#100
  def initialize(context, max_allowed_calls, allow_calls); end

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#106
  def calls; end

  # Returns the value of attribute context.
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#98
  def context; end

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#112
  def smelly_calls; end

  private

  # Returns the value of attribute allow_calls.
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#118
  def allow_calls; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#143
  def allow_calls?(method); end

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#122
  def collect_calls(result); end

  # Returns the value of attribute max_allowed_calls.
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#118
  def max_allowed_calls; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#139
  def simple_method_call?(call_node); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#134
  def smelly_call?(found_call); end
end

# source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#31
Reek::SmellDetectors::DuplicateMethodCall::DEFAULT_ALLOW_CALLS = T.let(T.unsafe(nil), Array)

# source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#25
Reek::SmellDetectors::DuplicateMethodCall::DEFAULT_MAX_CALLS = T.let(T.unsafe(nil), Integer)

# Collects information about a single found call
class Reek::SmellDetectors::DuplicateMethodCall::FoundCall
  # @return [FoundCall] a new instance of FoundCall
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#68
  def initialize(call_node); end

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#77
  def call; end

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#85
  def lines; end

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#81
  def occurs; end

  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#73
  def record(occurence); end

  private

  # Returns the value of attribute call_node.
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#91
  def call_node; end

  # Returns the value of attribute occurences.
  #
  # source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#91
  def occurences; end
end

# The name of the config field that sets the maximum number of
# identical calls to be permitted within any single method.
#
# source://reek//lib/reek/smell_detectors/duplicate_method_call.rb#24
Reek::SmellDetectors::DuplicateMethodCall::MAX_ALLOWED_CALLS_KEY = T.let(T.unsafe(nil), String)

# Feature Envy occurs when a code fragment references another object
# more often than it references itself, or when several clients do
# the same series of manipulations on a particular type of object.
#
# A simple example would be the following method, which "belongs"
# on the Item class and not on the Cart class:
#
#  class Cart
#    def price
#      @item.price + @item.tax
#    end
#  end
#
# Feature Envy reduces the code's ability to communicate intent:
# code that "belongs" on one class but which is located in another
# can be hard to find, and may upset the "System of Names"
# in the host class.
#
# Feature Envy also affects the design's flexibility: A code fragment
# that is in the wrong class creates couplings that may not be natural
# within the application's domain, and creates a loss of cohesion
# in the unwilling host class.
#
# Currently +FeatureEnvy+ reports any method that refers to self less
# often than it refers to (ie. send messages to) some other object.
#
# If the method doesn't reference self at all, +UtilityFunction+ is
# reported instead.
#
# See {file:docs/Feature-Envy.md} for details.
class Reek::SmellDetectors::FeatureEnvy < ::Reek::SmellDetectors::BaseDetector
  # Checks whether the given +context+ includes any code fragment that
  # might "belong" on another class.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/feature_envy.rb#45
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/feature_envy.rb#63
  def envious_receivers; end

  # source://reek//lib/reek/smell_detectors/feature_envy.rb#59
  def refs; end
end

# The +InstanceVariableAssumption+ class is responsible for
# detecting directly access of instance variables in a class
# that does not define them in its initialize method.
class Reek::SmellDetectors::InstanceVariableAssumption < ::Reek::SmellDetectors::BaseDetector
  # Checks +klass+ for instance
  # variables assumptions.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/instance_variable_assumption.rb#22
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/instance_variable_assumption.rb#36
  def build_smell_warning(assumption); end

  # source://reek//lib/reek/smell_detectors/instance_variable_assumption.rb#32
  def method_expressions; end

  # source://reek//lib/reek/smell_detectors/instance_variable_assumption.rb#55
  def variables_from_context; end

  # source://reek//lib/reek/smell_detectors/instance_variable_assumption.rb#45
  def variables_from_initialize; end

  class << self
    # source://reek//lib/reek/smell_detectors/instance_variable_assumption.rb#13
    def contexts; end
  end
end

# It is considered good practice to annotate every class and module
# with a brief comment outlining its responsibilities.
#
# See {file:docs/Irresponsible-Module.md} for details.
class Reek::SmellDetectors::IrresponsibleModule < ::Reek::SmellDetectors::BaseDetector
  # Checks the given class or module for a descriptive comment.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/irresponsible_module.rb#22
  def sniff; end

  private

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/irresponsible_module.rb#32
  def descriptive_context?; end

  class << self
    # source://reek//lib/reek/smell_detectors/irresponsible_module.rb#13
    def contexts; end
  end
end

# A Long Parameter List occurs when a method has more than one
# or two parameters, or when a method yields more than one or
# two objects to an associated block.
#
# Currently +LongParameterList+ reports any method or block with too
# many parameters.
#
# See {file:docs/Long-Parameter-List.md} for details.
class Reek::SmellDetectors::LongParameterList < ::Reek::SmellDetectors::BaseDetector
  # Checks the number of parameters in the given method.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/long_parameter_list.rb#35
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/long_parameter_list.rb#47
  def max_allowed_params; end

  class << self
    # source://reek//lib/reek/smell_detectors/long_parameter_list.rb#22
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/long_parameter_list.rb#20
Reek::SmellDetectors::LongParameterList::DEFAULT_MAX_ALLOWED_PARAMS = T.let(T.unsafe(nil), Integer)

# The name of the config field that sets the maximum number of
# parameters permitted in any method or block.
#
# source://reek//lib/reek/smell_detectors/long_parameter_list.rb#19
Reek::SmellDetectors::LongParameterList::MAX_ALLOWED_PARAMS_KEY = T.let(T.unsafe(nil), String)

# A variant on LongParameterList that checks the number of items
# passed to a block by a +yield+ call.
#
# See {file:docs/Long-Yield-List.md} for details.
class Reek::SmellDetectors::LongYieldList < ::Reek::SmellDetectors::BaseDetector
  # Checks the number of parameters in the given scope.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/long_yield_list.rb#28
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/long_yield_list.rb#42
  def max_allowed_params; end

  class << self
    # source://reek//lib/reek/smell_detectors/long_yield_list.rb#18
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/long_yield_list.rb#16
Reek::SmellDetectors::LongYieldList::DEFAULT_MAX_ALLOWED_PARAMS = T.let(T.unsafe(nil), Integer)

# The name of the config field that sets the maximum number of
# parameters permitted in any method or block.
#
# source://reek//lib/reek/smell_detectors/long_yield_list.rb#15
Reek::SmellDetectors::LongYieldList::MAX_ALLOWED_PARAMS_KEY = T.let(T.unsafe(nil), String)

# A Manual Dispatch occurs when a method is only called after a
# manual check that the method receiver is of the correct type.
#
# The +ManualDispatch+ checker reports any invocation of +respond_to?+
#
# See {file:docs/Manual-Dispatch.md} for details.
class Reek::SmellDetectors::ManualDispatch < ::Reek::SmellDetectors::BaseDetector
  # Checks for +respond_to?+ usage within the given method
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/manual_dispatch.rb#22
  def sniff; end
end

# source://reek//lib/reek/smell_detectors/manual_dispatch.rb#15
Reek::SmellDetectors::ManualDispatch::MESSAGE = T.let(T.unsafe(nil), String)

# Excerpt from:
# http://dablog.rubypal.com/2007/8/15/bang-methods-or-danger-will-rubyist
# since this sums it up really well:
#
#   The ! in method names that end with ! means, "This method is dangerous"
#   -- or, more precisely, this method is the "dangerous" version of an
#   equivalent method, with the same name minus the !. "Danger" is
#   relative; the ! doesn't mean anything at all unless the method name
#   it's in corresponds to a similar but bang-less method name.
#
#   Don't add ! to your destructive (receiver-changing) methods' names,
#   unless you consider the changing to be "dangerous" and you have a
#   "non-dangerous" equivalent method without the !. If some arbitrary
#   subset of destructive methods end with !, then the whole point of !
#   gets distorted and diluted, and ! ceases to convey any information
#   whatsoever.
#
# Such a method is called MissingSafeMethod and is reported as a smell.
#
# See {file:docs/Missing-Safe-Method.md} for details.
class Reek::SmellDetectors::MissingSafeMethod < ::Reek::SmellDetectors::BaseDetector
  # Given this code:
  #
  # class Alfa
  #   def bravo!
  #   end
  # end
  #
  # An example context could look like this:
  #
  # s(:class,
  #   s(:const, nil, :Alfa), nil,
  #     s(:def, :bravo!,
  #       s(:args), nil))
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/missing_safe_method.rb#49
  def sniff; end

  private

  # @param method_node [Reek::AST::Node] ,
  #   e.g. s(:def, :bravo!, s(:args), nil)
  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/missing_safe_method.rb#82
  def ignore_method?(method_node); end

  # e.g. ["bravo!"]
  #
  # source://reek//lib/reek/smell_detectors/missing_safe_method.rb#87
  def ignore_method_names; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/missing_safe_method.rb#63
  def missing_safe_method?(method_sexp); end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/missing_safe_method.rb#71
  def version_without_bang_exists?(method_sexp); end

  class << self
    # source://reek//lib/reek/smell_detectors/missing_safe_method.rb#28
    def contexts; end
  end
end

# a module is usually a mixin, so when initialize method is present it is
# hard to tell initialization order and parameters so having 'initialize'
# in a module is usually a bad idea
#
# See {file:docs/Module-Initialize.md} for details.
class Reek::SmellDetectors::ModuleInitialize < ::Reek::SmellDetectors::BaseDetector
  # Checks whether module has method 'initialize'.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/module_initialize.rb#23
  def sniff; end

  class << self
    # source://reek//lib/reek/smell_detectors/module_initialize.rb#14
    def contexts; end
  end
end

# A Nested Iterator occurs when a block contains another block.
#
# +NestedIterators+ reports failing methods only once.
#
# See {file:docs/Nested-Iterators.md} for details.
class Reek::SmellDetectors::NestedIterators < ::Reek::SmellDetectors::BaseDetector
  # Generates a smell warning for each independent deepest nesting depth
  # that is greater than our allowed maximum. This means if two iterators
  # with the same depth were found, we combine them into one warning and
  # merge the line information.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#44
  def sniff; end

  private

  # Finds the set of independent most deeply nested iterators regardless of
  # nesting depth.
  #
  # @return [Array<Iterator>]
  #
  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#75
  def find_candidates; end

  # Finds the set of independent most deeply nested iterators that are
  # nested more deeply than allowed.
  #
  # Here, independent means that if iterator A is contained within iterator
  # B, we only include A. But if iterators A and B are both contained in
  # iterator C, but A is not contained in B, nor B in A, both A and B are
  # included.
  #
  # @return [Array<Iterator>]
  #
  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#66
  def find_violations; end

  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#117
  def ignore_iterators; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#130
  def ignored_iterator?(exp); end

  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#121
  def increment_depth(iterator, depth); end

  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#125
  def max_allowed_nesting; end

  # A little digression into parser's sexp is necessary here:
  #
  # Given
  #   foo.each() do ... end
  # this will end up as:
  #
  # "foo.each() do ... end" -> one of the :block nodes
  # "each()"                -> the node's "call"
  # "do ... end"            -> the node's "block"
  #
  # @param exp [AST::Node] The given expression to analyze.
  # @param depth [Integer]
  # @return [Array<Iterator>]
  #
  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#97
  def scout(exp:, depth:); end

  class << self
    # source://reek//lib/reek/smell_detectors/nested_iterators.rb#31
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/nested_iterators.rb#29
Reek::SmellDetectors::NestedIterators::DEFAULT_IGNORE_ITERATORS = T.let(T.unsafe(nil), Array)

# source://reek//lib/reek/smell_detectors/nested_iterators.rb#24
Reek::SmellDetectors::NestedIterators::DEFAULT_MAX_ALLOWED_NESTING = T.let(T.unsafe(nil), Integer)

# The name of the config field that sets the names of any
# methods for which nesting should not be considered
#
# source://reek//lib/reek/smell_detectors/nested_iterators.rb#28
Reek::SmellDetectors::NestedIterators::IGNORE_ITERATORS_KEY = T.let(T.unsafe(nil), String)

# Struct for conveniently associating iterators with their depth (that is, their nesting).
class Reek::SmellDetectors::NestedIterators::Iterator < ::Struct
  # Returns the value of attribute depth
  #
  # @return [Object] the current value of depth
  def depth; end

  # Sets the attribute depth
  #
  # @param value [Object] the value to set the attribute depth to.
  # @return [Object] the newly set value
  def depth=(_); end

  # Returns the value of attribute exp
  #
  # @return [Object] the current value of exp
  def exp; end

  # Sets the attribute exp
  #
  # @param value [Object] the value to set the attribute exp to.
  # @return [Object] the newly set value
  def exp=(_); end

  # source://reek//lib/reek/smell_detectors/nested_iterators.rb#16
  def line; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# The name of the config field that sets the maximum depth
# of nested iterators to be permitted within any single method.
#
# source://reek//lib/reek/smell_detectors/nested_iterators.rb#23
Reek::SmellDetectors::NestedIterators::MAX_ALLOWED_NESTING_KEY = T.let(T.unsafe(nil), String)

# Checking for nil is a special kind of type check, and therefore a case of
# SimulatedPolymorphism.
#
# See {file:docs/Nil-Check.md} for details.
class Reek::SmellDetectors::NilCheck < ::Reek::SmellDetectors::BaseDetector
  # source://reek//lib/reek/smell_detectors/nil_check.rb#12
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/nil_check.rb#25
  def detect_nodes; end
end

# Detect 'call' nodes which perform a nil check.
module Reek::SmellDetectors::NilCheck::NilCallNodeDetector
  private

  # source://reek//lib/reek/smell_detectors/nil_check.rb#69
  def comparison_call?(call); end

  # source://reek//lib/reek/smell_detectors/nil_check.rb#77
  def comparison_methods; end

  # source://reek//lib/reek/smell_detectors/nil_check.rb#57
  def detect(node); end

  # source://reek//lib/reek/smell_detectors/nil_check.rb#73
  def involves_nil?(call); end

  # source://reek//lib/reek/smell_detectors/nil_check.rb#65
  def nil_comparison?(call); end

  # source://reek//lib/reek/smell_detectors/nil_check.rb#61
  def nil_query?(call); end

  class << self
    # @return [Boolean]
    #
    # source://reek//lib/reek/smell_detectors/nil_check.rb#69
    def comparison_call?(call); end

    # source://reek//lib/reek/smell_detectors/nil_check.rb#77
    def comparison_methods; end

    # source://reek//lib/reek/smell_detectors/nil_check.rb#57
    def detect(node); end

    # @return [Boolean]
    #
    # source://reek//lib/reek/smell_detectors/nil_check.rb#73
    def involves_nil?(call); end

    # @return [Boolean]
    #
    # source://reek//lib/reek/smell_detectors/nil_check.rb#65
    def nil_comparison?(call); end

    # @return [Boolean]
    #
    # source://reek//lib/reek/smell_detectors/nil_check.rb#61
    def nil_query?(call); end
  end
end

# Detect 'when' statements that perform a nil check.
module Reek::SmellDetectors::NilCheck::NilWhenNodeDetector
  private

  # source://reek//lib/reek/smell_detectors/nil_check.rb#86
  def detect(node); end

  class << self
    # source://reek//lib/reek/smell_detectors/nil_check.rb#86
    def detect(node); end
  end
end

# A base class that allows to work on all nodes of a certain type.
class Reek::SmellDetectors::NilCheck::NodeFinder
  # @return [NodeFinder] a new instance of NodeFinder
  #
  # source://reek//lib/reek/smell_detectors/nil_check.rb#35
  def initialize(ctx, type, detector); end

  # source://reek//lib/reek/smell_detectors/nil_check.rb#40
  def smelly_nodes; end

  private

  # Returns the value of attribute detector.
  #
  # source://reek//lib/reek/smell_detectors/nil_check.rb#48
  def detector; end

  # Returns the value of attribute nodes.
  #
  # source://reek//lib/reek/smell_detectors/nil_check.rb#48
  def nodes; end
end

# Simulated Polymorphism occurs when
# * code uses a case statement (especially on a type field);
# * or code has several if statements in a row
#   (especially if they're comparing against the same value);
# * or code uses instance_of?, kind_of?, is_a?, or ===
#   to decide what type it's working with;
# * or multiple conditionals in different places test the same value.
#
# Conditional code is hard to read and understand, because the reader must
# hold more state in his head.
# When the same value is tested in multiple places throughout an application,
# any change to the set of possible values will require many methods and
# classes to change. Tests for the type of an object may indicate that the
# abstraction represented by that type is not completely defined (or understood).
#
# +RepeatedConditional+ checks for multiple conditionals
# testing the same value throughout a single class.
#
# See {file:docs/Repeated-Conditional.md} for details.
class Reek::SmellDetectors::RepeatedConditional < ::Reek::SmellDetectors::BaseDetector
  # Checks the given class for multiple identical conditional tests.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/repeated_conditional.rb#50
  def sniff; end

  private

  # Returns a Hash listing all of the conditional expressions in
  # the given syntax tree together with the number of times each
  # occurs. Ignores nested classes and modules.
  #
  # source://reek//lib/reek/smell_detectors/repeated_conditional.rb#75
  def conditional_counts; end

  # source://reek//lib/reek/smell_detectors/repeated_conditional.rb#65
  def max_identical_ifs; end

  class << self
    # source://reek//lib/reek/smell_detectors/repeated_conditional.rb#36
    def contexts; end

    # source://reek//lib/reek/smell_detectors/repeated_conditional.rb#40
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/repeated_conditional.rb#34
Reek::SmellDetectors::RepeatedConditional::BLOCK_GIVEN_CONDITION = T.let(T.unsafe(nil), Parser::AST::Node)

# source://reek//lib/reek/smell_detectors/repeated_conditional.rb#32
Reek::SmellDetectors::RepeatedConditional::DEFAULT_MAX_IFS = T.let(T.unsafe(nil), Integer)

# The name of the config field that sets the maximum number of
# identical conditionals permitted within any single class.
#
# source://reek//lib/reek/smell_detectors/repeated_conditional.rb#31
Reek::SmellDetectors::RepeatedConditional::MAX_IDENTICAL_IFS_KEY = T.let(T.unsafe(nil), String)

# Subclassing core classes in Ruby can lead to unexpected side effects.
# Knowing that Ruby has a core library, which is written in C, and a standard
# library, which is written in Ruby, if you do not know exactly how these core
# classes operate at the C level, you are gonna have a bad time.
#
# Source: http://words.steveklabnik.com/beware-subclassing-ruby-core-classes
class Reek::SmellDetectors::SubclassedFromCoreClass < ::Reek::SmellDetectors::BaseDetector
  # Checks +ctx+ for either expressions:
  #
  # Foo = Class.new(Bar)
  #
  # class Foo < Bar; end;
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/subclassed_from_core_class.rb#29
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/subclassed_from_core_class.rb#45
  def build_smell_warning(ancestor_name); end

  # source://reek//lib/reek/smell_detectors/subclassed_from_core_class.rb#39
  def sniff_superclass(superclass_name); end

  class << self
    # source://reek//lib/reek/smell_detectors/subclassed_from_core_class.rb#18
    def contexts; end
  end
end

# source://reek//lib/reek/smell_detectors/subclassed_from_core_class.rb#16
Reek::SmellDetectors::SubclassedFromCoreClass::CORE_CLASSES = T.let(T.unsafe(nil), Array)

# A Large Class is a class or module that has a large number of
# instance variables, methods, constants or lines of code.
#
# +TooManyConstants' reports classes having more than a
# configurable number of constants.
#
# See {file:docs/Too-Many-Constants.md} for details.
class Reek::SmellDetectors::TooManyConstants < ::Reek::SmellDetectors::BaseDetector
  # Checks +klass+ for too many constants.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/too_many_constants.rb#37
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/too_many_constants.rb#51
  def build_smell_warning(count); end

  # source://reek//lib/reek/smell_detectors/too_many_constants.rb#47
  def max_allowed_constants; end

  class << self
    # source://reek//lib/reek/smell_detectors/too_many_constants.rb#22
    def contexts; end

    # source://reek//lib/reek/smell_detectors/too_many_constants.rb#26
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/too_many_constants.rb#19
Reek::SmellDetectors::TooManyConstants::DEFAULT_MAX_CONSTANTS = T.let(T.unsafe(nil), Integer)

# source://reek//lib/reek/smell_detectors/too_many_constants.rb#20
Reek::SmellDetectors::TooManyConstants::IGNORED_NODES = T.let(T.unsafe(nil), Array)

# The name of the config field that sets the maximum number
# of constants permitted in a class.
#
# source://reek//lib/reek/smell_detectors/too_many_constants.rb#18
Reek::SmellDetectors::TooManyConstants::MAX_ALLOWED_CONSTANTS_KEY = T.let(T.unsafe(nil), String)

# A Large Class is a class or module that has a large number of
# instance variables, methods or lines of code.
#
# +TooManyInstanceVariables' reports classes having more than a
# configurable number of instance variables.
#
# See {file:docs/Too-Many-Instance-Variables.md} for details.
class Reek::SmellDetectors::TooManyInstanceVariables < ::Reek::SmellDetectors::BaseDetector
  # Checks +klass+ for too many instance variables.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/too_many_instance_variables.rb#36
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/too_many_instance_variables.rb#49
  def max_allowed_ivars; end

  class << self
    # source://reek//lib/reek/smell_detectors/too_many_instance_variables.rb#21
    def contexts; end

    # source://reek//lib/reek/smell_detectors/too_many_instance_variables.rb#25
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/too_many_instance_variables.rb#19
Reek::SmellDetectors::TooManyInstanceVariables::DEFAULT_MAX_IVARS = T.let(T.unsafe(nil), Integer)

# The name of the config field that sets the maximum number of instance
# variables permitted in a class.
#
# source://reek//lib/reek/smell_detectors/too_many_instance_variables.rb#18
Reek::SmellDetectors::TooManyInstanceVariables::MAX_ALLOWED_IVARS_KEY = T.let(T.unsafe(nil), String)

# A Large Class is a class or module that has a large number of
# instance variables, methods or lines of code.
#
# +TooManyMethods+ reports classes having more than a configurable number
# of methods. The method count includes public, protected and private
# methods, and excludes methods inherited from superclasses or included
# modules.
#
# See {file:docs/Too-Many-Methods.md} for details.
class Reek::SmellDetectors::TooManyMethods < ::Reek::SmellDetectors::BaseDetector
  # Checks context for too many methods
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/too_many_methods.rb#38
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/too_many_methods.rb#51
  def max_allowed_methods; end

  class << self
    # source://reek//lib/reek/smell_detectors/too_many_methods.rb#23
    def contexts; end

    # source://reek//lib/reek/smell_detectors/too_many_methods.rb#27
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/too_many_methods.rb#21
Reek::SmellDetectors::TooManyMethods::DEFAULT_MAX_METHODS = T.let(T.unsafe(nil), Integer)

# The name of the config field that sets the maximum number of methods
# permitted in a class.
#
# source://reek//lib/reek/smell_detectors/too_many_methods.rb#20
Reek::SmellDetectors::TooManyMethods::MAX_ALLOWED_METHODS_KEY = T.let(T.unsafe(nil), String)

# A Long Method is any method that has a large number of lines.
#
# +TooManyStatements+ reports any method with more than 5 statements.
#
# See {file:docs/Too-Many-Statements.md} for details.
class Reek::SmellDetectors::TooManyStatements < ::Reek::SmellDetectors::BaseDetector
  # Checks the length of the given +method+.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/too_many_statements.rb#30
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/too_many_statements.rb#42
  def max_allowed_statements; end

  class << self
    # source://reek//lib/reek/smell_detectors/too_many_statements.rb#19
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/too_many_statements.rb#17
Reek::SmellDetectors::TooManyStatements::DEFAULT_MAX_STATEMENTS = T.let(T.unsafe(nil), Integer)

# The name of the config field that sets the maximum number of
# statements permitted in any method.
#
# source://reek//lib/reek/smell_detectors/too_many_statements.rb#16
Reek::SmellDetectors::TooManyStatements::MAX_ALLOWED_STATEMENTS_KEY = T.let(T.unsafe(nil), String)

# An Uncommunicative Name is a name that doesn't communicate its intent
# well enough.
#
# Poor names make it hard for the reader to build a mental picture
# of what's going on in the code. They can also be mis-interpreted;
# and they hurt the flow of reading, because the reader must slow
# down to interpret the names.
#
# Currently +UncommunicativeMethodName+ checks for
# * 1-character names
# * names ending with a number
# * names containing a capital letter (assuming camelCase)
#
# See {file:docs/Uncommunicative-Method-Name.md} for details.
class Reek::SmellDetectors::UncommunicativeMethodName < ::Reek::SmellDetectors::BaseDetector
  # Checks the given +context+ for uncommunicative names.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#39
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#60
  def accept_patterns; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#51
  def acceptable_name?(name); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#56
  def reject_patterns; end

  class << self
    # source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#28
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#24
Reek::SmellDetectors::UncommunicativeMethodName::ACCEPT_KEY = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#26
Reek::SmellDetectors::UncommunicativeMethodName::DEFAULT_ACCEPT_PATTERNS = T.let(T.unsafe(nil), Array)

# source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#25
Reek::SmellDetectors::UncommunicativeMethodName::DEFAULT_REJECT_PATTERNS = T.let(T.unsafe(nil), Array)

# source://reek//lib/reek/smell_detectors/uncommunicative_method_name.rb#23
Reek::SmellDetectors::UncommunicativeMethodName::REJECT_KEY = T.let(T.unsafe(nil), String)

# An Uncommunicative Name is a name that doesn't communicate its intent
# well enough.
#
# Poor names make it hard for the reader to build a mental picture
# of what's going on in the code. They can also be mis-interpreted;
# and they hurt the flow of reading, because the reader must slow
# down to interpret the names.
#
# Currently +UncommunicativeModuleName+ checks for
# * 1-character names
# * names ending with a number
#
# See {file:docs/Uncommunicative-Module-Name.md} for details.
class Reek::SmellDetectors::UncommunicativeModuleName < ::Reek::SmellDetectors::BaseDetector
  # Checks the detector's context for uncommunicative names.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#48
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#72
  def accept_patterns; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#63
  def acceptable_name?(module_name:, fully_qualified_name:); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#68
  def reject_patterns; end

  class << self
    # source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#39
    def contexts; end

    # source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#33
    def default_config; end
  end
end

# The name of the config field that lists the specific names that are
# to be treated as exceptions; these names will not be reported as
# uncommunicative.
#
# source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#30
Reek::SmellDetectors::UncommunicativeModuleName::ACCEPT_KEY = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#31
Reek::SmellDetectors::UncommunicativeModuleName::DEFAULT_ACCEPT_PATTERNS = T.let(T.unsafe(nil), Array)

# source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#25
Reek::SmellDetectors::UncommunicativeModuleName::DEFAULT_REJECT_PATTERNS = T.let(T.unsafe(nil), Array)

# The name of the config field that lists the regexps of
# smelly names to be reported.
#
# source://reek//lib/reek/smell_detectors/uncommunicative_module_name.rb#24
Reek::SmellDetectors::UncommunicativeModuleName::REJECT_KEY = T.let(T.unsafe(nil), String)

# An Uncommunicative Name is a name that doesn't communicate its intent
# well enough.
#
# Poor names make it hard for the reader to build a mental picture
# of what's going on in the code. They can also be mis-interpreted;
# and they hurt the flow of reading, because the reader must slow
# down to interpret the names.
#
# Currently +UncommunicativeParameterName+ checks for
# * 1-character names
# * names ending with a number
# * names beginning with an underscore
# * names containing a capital letter (assuming camelCase)
#
# See {file:docs/Uncommunicative-Parameter-Name.md} for details.
class Reek::SmellDetectors::UncommunicativeParameterName < ::Reek::SmellDetectors::BaseDetector
  # Checks the given +context+ for uncommunicative names.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#41
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#70
  def accept_patterns; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#61
  def acceptable_name?(name); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#66
  def reject_patterns; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#56
  def uncommunicative_parameter?(parameter); end

  class << self
    # source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#30
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#27
Reek::SmellDetectors::UncommunicativeParameterName::ACCEPT_KEY = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#28
Reek::SmellDetectors::UncommunicativeParameterName::DEFAULT_ACCEPT_PATTERNS = T.let(T.unsafe(nil), Array)

# source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#25
Reek::SmellDetectors::UncommunicativeParameterName::DEFAULT_REJECT_PATTERNS = T.let(T.unsafe(nil), Array)

# source://reek//lib/reek/smell_detectors/uncommunicative_parameter_name.rb#24
Reek::SmellDetectors::UncommunicativeParameterName::REJECT_KEY = T.let(T.unsafe(nil), String)

# An Uncommunicative Name is a name that doesn't communicate its intent
# well enough.
#
# Poor names make it hard for the reader to build a mental picture
# of what's going on in the code. They can also be mis-interpreted;
# and they hurt the flow of reading, because the reader must slow
# down to interpret the names.
#
# Currently +UncommunicativeName+ checks for:
#
# * single-character names
# * any name ending with a number
# * camelCaseVariableNames
#
# See {file:docs/Uncommunicative-Variable-Name.md} for details.
class Reek::SmellDetectors::UncommunicativeVariableName < ::Reek::SmellDetectors::BaseDetector
  # Checks the given +context+ for uncommunicative names.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#55
  def sniff; end

  private

  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#72
  def accept_names; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#81
  def acceptable_name?(name); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#93
  def find_assignment_variable_names(accumulator); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#105
  def find_block_argument_variable_names(accumulator); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#134
  def record_variable_name(exp, symbol, accumulator); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#122
  def recursively_record_variable_names(accumulator, exp); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#68
  def reject_names; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#76
  def uncommunicative_variable_name?(name); end

  # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#86
  def variable_names; end

  class << self
    # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#46
    def contexts; end

    # source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#40
    def default_config; end
  end
end

# The name of the config field that lists the specific names that are
# to be treated as exceptions; these names will not be reported as
# uncommunicative.
#
# source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#37
Reek::SmellDetectors::UncommunicativeVariableName::ACCEPT_KEY = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#38
Reek::SmellDetectors::UncommunicativeVariableName::DEFAULT_ACCEPT_SET = T.let(T.unsafe(nil), Array)

# source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#28
Reek::SmellDetectors::UncommunicativeVariableName::DEFAULT_REJECT_SET = T.let(T.unsafe(nil), Array)

# The name of the config field that lists the regexps of
# smelly names to be reported.
#
# source://reek//lib/reek/smell_detectors/uncommunicative_variable_name.rb#27
Reek::SmellDetectors::UncommunicativeVariableName::REJECT_KEY = T.let(T.unsafe(nil), String)

# Methods should use their parameters.
#
# See {file:docs/Unused-Parameters.md} for details.
class Reek::SmellDetectors::UnusedParameters < ::Reek::SmellDetectors::BaseDetector
  # Checks whether the given method has any unused parameters.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/unused_parameters.rb#17
  def sniff; end
end

# Classes should use their private methods. Otherwise this is dead
# code which is confusing and bad for maintenance.
#
# See {file:docs/Unused-Private-Method.md} for details.
class Reek::SmellDetectors::UnusedPrivateMethod < ::Reek::SmellDetectors::BaseDetector
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/unused_private_method.rb#37
  def sniff; end

  private

  # @return [Array<Hit>]
  #
  # source://reek//lib/reek/smell_detectors/unused_private_method.rb#52
  def hits; end

  # @param method [Context::MethodContext]
  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/unused_private_method.rb#75
  def ignore_method?(method); end

  # @return [Array<Context::MethodContext]] Array<Context::MethodContext]
  #
  # source://reek//lib/reek/smell_detectors/unused_private_method.rb#61
  def unused_private_methods; end

  class << self
    # source://reek//lib/reek/smell_detectors/unused_private_method.rb#30
    def contexts; end

    # source://reek//lib/reek/smell_detectors/unused_private_method.rb#14
    def default_config; end
  end
end

# Class for storing `hits` which are unused private methods
# we found in the given context. `name` and `line` are then used to
# construct SmellWarnings.
class Reek::SmellDetectors::UnusedPrivateMethod::Hit
  # @return [Hit] a new instance of Hit
  #
  # source://reek//lib/reek/smell_detectors/unused_private_method.rb#24
  def initialize(context); end

  # Returns the value of attribute line.
  #
  # source://reek//lib/reek/smell_detectors/unused_private_method.rb#22
  def line; end

  # Returns the value of attribute name.
  #
  # source://reek//lib/reek/smell_detectors/unused_private_method.rb#22
  def name; end
end

# A Utility Function is any instance method that has no
# dependency on the state of the instance.
#
# Currently +UtilityFunction+ will warn about any method that:
#
# * is non-empty, and
# * does not override an inherited method, and
# * calls at least one method on another object, and
# * doesn't use any of self's instance variables, and
# * doesn't use any of self's methods
#
# A Utility Function often arises because it must manipulate
# other objects (usually its arguments) to get them into a
# useful form; one force preventing them (the
# arguments) doing this themselves is that the common
# knowledge lives outside the arguments, or the arguments
# are of too basic a type to justify extending that type.
# Therefore there must be something which 'knows' about the contents
# or purposes of the arguments.  That thing would have to
# be more than just a basic type, because the basic types
# are either containers which don't know about their
# contents, or they are single objects which can't capture
# their relationship with their fellows of the same type.
# So, this thing with the extra knowledge should be
# reified into a class, and the utility method will most
# likely belong there.
#
# If the method does refer to self, but refers to some other object more,
# +FeatureEnvy+ is reported instead.
#
# See {file:docs/Utility-Function.md} for details.
class Reek::SmellDetectors::UtilityFunction < ::Reek::SmellDetectors::BaseDetector
  # Checks whether the given +method+ is a utility function.
  #
  # @return [Array<SmellWarning>]
  #
  # source://reek//lib/reek/smell_detectors/utility_function.rb#59
  def sniff; end

  private

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_detectors/utility_function.rb#76
  def ignore_method?; end

  # source://reek//lib/reek/smell_detectors/utility_function.rb#72
  def num_helper_methods; end

  class << self
    # source://reek//lib/reek/smell_detectors/utility_function.rb#49
    def contexts; end

    # source://reek//lib/reek/smell_detectors/utility_function.rb#44
    def default_config; end
  end
end

# source://reek//lib/reek/smell_detectors/utility_function.rb#42
Reek::SmellDetectors::UtilityFunction::PUBLIC_METHODS_ONLY_DEFAULT = T.let(T.unsafe(nil), FalseClass)

# source://reek//lib/reek/smell_detectors/utility_function.rb#41
Reek::SmellDetectors::UtilityFunction::PUBLIC_METHODS_ONLY_KEY = T.let(T.unsafe(nil), String)

# Reports a warning that a smell has been found.
class Reek::SmellWarning
  include ::Comparable
  extend ::Forwardable

  # @note When using Reek's public API, you should not create SmellWarning
  #   objects yourself. This is why the initializer is not part of the
  #   public API.
  # @param smell_type [String] type of detected smell; corresponds to
  #   detector#smell_type
  # @param context [String] name of the context in which the smell occured
  # @param lines [Array<Integer>] list of lines on which the smell occured
  # @param message [String] text describing the smell in more detail
  # @param source [String] name of the source (e.g., the file name) in which
  #   the smell occured
  # @param parameters [Hash] smell-specific parameters
  # @return [SmellWarning] a new instance of SmellWarning
  #
  # source://reek//lib/reek/smell_warning.rb#34
  def initialize(smell_type, lines:, message:, source:, context: T.unsafe(nil), parameters: T.unsafe(nil)); end

  # source://reek//lib/reek/smell_warning.rb#51
  def <=>(other); end

  # source://reek//lib/reek/smell_warning.rb#70
  def base_message; end

  # Returns the value of attribute context.
  #
  # source://reek//lib/reek/smell_warning.rb#18
  def context; end

  # @return [Boolean]
  #
  # source://reek//lib/reek/smell_warning.rb#56
  def eql?(other); end

  # source://reek//lib/reek/smell_warning.rb#74
  def explanatory_link; end

  # source://reek//lib/reek/smell_warning.rb#46
  def hash; end

  # Returns the value of attribute lines.
  #
  # source://reek//lib/reek/smell_warning.rb#18
  def lines; end

  # Returns the value of attribute message.
  #
  # source://reek//lib/reek/smell_warning.rb#18
  def message; end

  # Returns the value of attribute parameters.
  #
  # source://reek//lib/reek/smell_warning.rb#18
  def parameters; end

  # Returns the value of attribute smell_type.
  #
  # source://reek//lib/reek/smell_warning.rb#18
  def smell_type; end

  # Returns the value of attribute source.
  #
  # source://reek//lib/reek/smell_warning.rb#18
  def source; end

  # source://reek//lib/reek/smell_warning.rb#61
  def to_hash; end

  # source://reek//lib/reek/smell_warning.rb#66
  def yaml_hash; end

  protected

  # source://reek//lib/reek/smell_warning.rb#80
  def identifying_values; end

  private

  # source://reek//lib/reek/smell_warning.rb#86
  def base_hash; end
end

module Reek::Source; end

# A +SourceCode+ object represents a chunk of Ruby source code.
class Reek::Source::SourceCode
  # Initializer.
  #
  # @param source [File|Pathname|IO|String] Ruby source code
  # @param origin [String] Origin of the source code. Will be determined
  #   automatically if left blank.
  # @param parser the parser to use for generating AST's out of the given code
  # @return [SourceCode] a new instance of SourceCode
  #
  # source://reek//lib/reek/source/source_code.rb#28
  def initialize(source:, origin: T.unsafe(nil), parser: T.unsafe(nil)); end

  # source://reek//lib/reek/source/source_code.rb#64
  def origin; end

  # source://reek//lib/reek/source/source_code.rb#52
  def syntax_tree; end

  private

  # source://reek//lib/reek/source/source_code.rb#76
  def code; end

  # Parses the given code into an AST and associates the source code comments with it.
  # This AST is then traversed by a TreeDresser which adorns the nodes in the AST
  # with our SexpExtensions.
  # Finally this AST is returned where each node is an anonymous subclass of Reek::AST::Node
  #
  # Given this @code:
  #
  #   # comment about C
  #   class C
  #     def m
  #       puts 'nada'
  #     end
  #   end
  #
  # this method would return something that looks like
  #
  #   (class
  #     (const nil :C) nil
  #     (def :m
  #       (args)
  #       (send nil :puts
  #         (str "nada"))))
  #
  # where each node is possibly adorned with our SexpExtensions (see ast/ast_node_class_map
  # and ast/sexp_extensions for details).
  #
  # @return Reek::AST::Node the AST presentation for the given code
  #
  # source://reek//lib/reek/source/source_code.rb#114
  def parse; end

  # Returns the value of attribute parser.
  #
  # source://reek//lib/reek/source/source_code.rb#85
  def parser; end

  # Returns the value of attribute source.
  #
  # source://reek//lib/reek/source/source_code.rb#85
  def source; end

  class << self
    # source://reek//lib/reek/source/source_code.rb#56
    def default_parser; end

    # Initializes an instance of SourceCode given a source.
    # This source can come via several different ways:
    # - from Files or Pathnames a la `reek lib/reek/`
    # - from IO (STDIN) a la `echo "class Foo; end" | reek`
    # - from String via our rspec matchers a la `expect("class Foo; end").to reek`
    # - from an existing SourceCode object. This is passed through unchanged
    #
    # @param source [SourceCode|File|Pathname|IO|String] the given source
    # @param origin [String|nil]
    # @return an instance of SourceCode
    #
    # source://reek//lib/reek/source/source_code.rb#45
    def from(source, origin: T.unsafe(nil)); end
  end
end

# source://reek//lib/reek/source/source_code.rb#19
Reek::Source::SourceCode::IO_IDENTIFIER = T.let(T.unsafe(nil), String)

# source://reek//lib/reek/source/source_code.rb#20
Reek::Source::SourceCode::STRING_IDENTIFIER = T.let(T.unsafe(nil), String)

# Adorns an abstract syntax tree with mix-in modules to make accessing
# the tree more understandable and less implementation-dependent.
class Reek::TreeDresser
  # @return [TreeDresser] a new instance of TreeDresser
  #
  # source://reek//lib/reek/tree_dresser.rb#11
  def initialize(klass_map: T.unsafe(nil)); end

  # Recursively enhance an AST with type-dependent mixins, and comments.
  #
  # See {file:docs/How-reek-works-internally.md} for the big picture of how this works.
  # Example:
  # This
  #   class Klazz; def meth(argument); argument.call_me; end; end
  # corresponds to this sexp:
  #   (class
  #     (const nil :Klazz) nil
  #     (def :meth
  #       (args
  #         (arg :argument))
  #       (send
  #         (lvar :argument) :call_me)))
  # where every node is of type Parser::AST::Node.
  # Passing this into `dress` will return the exact same structure, but this
  # time the nodes will contain type-dependent mixins, e.g. this:
  #   (const nil :Klazz)
  #  will be of type Reek::AST::Node with  Reek::AST::SexpExtensions::ConstNode mixed in.
  #
  # @param sexp [Parser::AST::Node] the given sexp
  # @param comment_map [Hash] see the documentation for SourceCode#syntax_tree
  # @return an instance of Reek::AST::Node with type-dependent sexp extensions mixed in.
  #
  # source://reek//lib/reek/tree_dresser.rb#42
  def dress(sexp, comment_map); end

  private

  # Returns the value of attribute klass_map.
  #
  # source://reek//lib/reek/tree_dresser.rb#54
  def klass_map; end
end

# This module holds the Reek version information
module Reek::Version; end

# source://reek//lib/reek/version.rb#11
Reek::Version::STRING = T.let(T.unsafe(nil), String)
